<?xml version="1.0" encoding="UTF-8"?>
	<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">

<!-- 
===================================================================================
 Database Changelog v1.69 - Convert 5 High-Impact Views to Materialized Views
 
 Purpose: Convert 5 high-impact views to MATERIALIZED VIEW for 60-80% performance
          improvement on frequently-accessed complex queries across Pattern Recognition,
          Predictive Intelligence, and Temporal Analysis frameworks.
 
 Background: Performance analysis identified 5 views with expensive window functions,
             self-joins, and complex aggregations that benefit from materialization.
 
 Performance Impact (Projected with 3.5M votes):
 1. view_decision_temporal_trends: 3s → 1.8s (40% faster, daily refresh)
 2. view_riksdagen_politician_influence_metrics: 5-15s → 1-3s (80% faster, weekly refresh)
 3. view_party_effectiveness_trends: 1.5s → &lt;800ms (50% faster, quarterly refresh)
 4. view_politician_behavioral_trends: 4s → 2.6s (35% faster, monthly refresh)
 5. view_election_cycle_temporal_trends: 5-10s → &lt;3s (70% faster, post-election refresh)
 
 Implementation Strategy:
 - Convert regular views to MATERIALIZED VIEW via DROP VIEW + CREATE MATERIALIZED VIEW
 - Add performance indexes on each materialized view
 - Include rollback logic to revert to regular views if needed
 - Document refresh schedules in COMMENT ON statements
 
 Related Issues:
 - GitHub Issue: Hack23/cia#8283 (Convert 5 Views to Materialized)
 - PATTERN_RECOGNITION_PERFORMANCE_REPORT.md: Identifies 4 views for materialization
 - TEMPORAL_ANALYSIS_PERFORMANCE_REPORT.md: Identifies temporal views for materialization
 
 After Applying:
 - All 5 materialized views created but empty (WITH NO DATA)
 - Must run REFRESH MATERIALIZED VIEW on each to populate data
 - Indexes will be created automatically after first refresh
===================================================================================
-->

<changeSet id="1.69-intro" author="performance-engineer">
    <comment>
        Database Changelog v1.69 - Convert 5 High-Impact Views to Materialized Views
        
        Converts 5 high-impact views to materialized views for 60-80% performance
        improvement. Each view is converted from regular VIEW to MATERIALIZED VIEW
        with appropriate indexes for query optimization.
        
        Views Converted:
        1. view_decision_temporal_trends (40% faster, daily refresh)
        2. view_riksdagen_politician_influence_metrics (80% faster, weekly refresh)
        3. view_party_effectiveness_trends (50% faster, quarterly refresh)
        4. view_politician_behavioral_trends (35% faster, monthly refresh)
        5. view_election_cycle_temporal_trends (70% faster, post-election refresh)
        
        All materialized views created WITH NO DATA - must refresh after applying.
    </comment>
</changeSet>

<!-- 
===================================================================================
 VIEW 1: view_decision_temporal_trends
 
 Issue: 8 window functions with overlapping frames (7/30/90-day moving averages)
 Current Performance: 3 seconds
 Target Performance: 1.8 seconds (40% improvement)
 Refresh Schedule: Daily at 02:00 UTC
===================================================================================
-->

<changeSet id="1.69-001-materialize-decision_temporal_trends" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <viewExists viewName="view_decision_temporal_trends"/>
        <sqlCheck expectedResult="0">
            SELECT COUNT(*) FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'view_decision_temporal_trends'
        </sqlCheck>
    </preConditions>
    <comment>
        Convert view_decision_temporal_trends to MATERIALIZED VIEW for 40% performance improvement.
        
        Issue: 8 window functions with overlapping frames (7/30/90-day moving averages)
        Current: 3 seconds
        Target: 1.8 seconds
        Refresh: Daily at 02:00 UTC
    </comment>
    <sql splitStatements="false">
        DROP VIEW IF EXISTS view_decision_temporal_trends CASCADE;
        
        CREATE MATERIALIZED VIEW view_decision_temporal_trends AS
 WITH daily_decisions AS (
         SELECT dd.made_public_date AS decision_day,
            count(*) AS daily_decisions,
            round(((100.0 * (count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%BIFALL%'::text) OR (upper((dpd.chamber)::text) ~~ '%GODKÄNT%'::text) OR (upper((dpd.chamber)::text) ~~ '%BIFALLA%'::text))))::numeric) / (NULLIF(count(*), 0))::numeric), 2) AS daily_approval_rate,
            count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%BIFALL%'::text) OR (upper((dpd.chamber)::text) ~~ '%GODKÄNT%'::text) OR (upper((dpd.chamber)::text) ~~ '%BIFALLA%'::text))) AS approved_decisions,
            count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%AVSLAG%'::text) OR (upper((dpd.chamber)::text) ~~ '%AVSLÅ%'::text))) AS rejected_decisions,
            count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%ÅTERFÖRVISNING%'::text) OR (upper((dpd.chamber)::text) ~~ '%ÅTERFÖRVISA%'::text))) AS referred_back_decisions,
            count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%UTSKOTT%'::text) AND (upper((dpd.chamber)::text) !~~ '%ÅTERFÖRVISNING%'::text))) AS committee_referral_decisions
           FROM (((public.document_proposal_data dpd
             JOIN public.document_proposal_container dpc ON ((dpc.proposal_document_proposal_c_0 = dpd.hjid)))
             JOIN public.document_status_container dsc ON ((dsc.document_proposal_document_s_0 = dpc.hjid)))
             JOIN public.document_data dd ON (((dd.id)::text = (dsc.document_document_status_con_0)::text)))
          WHERE ((dd.made_public_date IS NOT NULL) AND (dd.made_public_date &gt;= (CURRENT_DATE - '5 years'::interval)) AND (dpd.chamber IS NOT NULL) AND (length((dpd.chamber)::text) &gt;= 6) AND (length((dpd.chamber)::text) &lt;= 29))
          GROUP BY dd.made_public_date
        )
 SELECT decision_day,
    daily_decisions,
    daily_approval_rate,
    approved_decisions,
    rejected_decisions,
    referred_back_decisions,
    committee_referral_decisions,
    round(avg(daily_decisions) OVER (ORDER BY decision_day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW), 2) AS ma_7day_decisions,
    round(avg(daily_decisions) OVER (ORDER BY decision_day ROWS BETWEEN 29 PRECEDING AND CURRENT ROW), 2) AS ma_30day_decisions,
    round(avg(daily_decisions) OVER (ORDER BY decision_day ROWS BETWEEN 89 PRECEDING AND CURRENT ROW), 2) AS ma_90day_decisions,
    round(avg(daily_approval_rate) OVER (ORDER BY decision_day ROWS BETWEEN 29 PRECEDING AND CURRENT ROW), 2) AS ma_30day_approval_rate,
    lag(daily_decisions, 365) OVER (ORDER BY decision_day) AS decisions_last_year,
    (daily_decisions - lag(daily_decisions, 365) OVER (ORDER BY decision_day)) AS yoy_decisions_change,
    round(((100.0 * ((daily_decisions - lag(daily_decisions, 365) OVER (ORDER BY decision_day)))::numeric) / (NULLIF(lag(daily_decisions, 365) OVER (ORDER BY decision_day), 0))::numeric), 2) AS yoy_decisions_change_pct,
    EXTRACT(year FROM decision_day) AS decision_year,
    EXTRACT(month FROM decision_day) AS decision_month,
    EXTRACT(week FROM decision_day) AS decision_week,
    EXTRACT(dow FROM decision_day) AS decision_day_of_week,
        CASE
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(7)::numeric, (8)::numeric])) THEN 'Summer Recess'::text
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(12)::numeric, (1)::numeric])) THEN 'Winter Recess'::text
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(2)::numeric, (3)::numeric])) THEN 'Spring Session'::text
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(9)::numeric, (10)::numeric, (11)::numeric])) THEN 'Autumn Session'::text
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(4)::numeric, (5)::numeric, (6)::numeric])) THEN 'Late Spring Session'::text
            ELSE 'Active Session'::text
        END AS parliamentary_period,
    ((('Q'::text || (EXTRACT(quarter FROM decision_day))::text) || ' '::text) || (EXTRACT(year FROM decision_day))::text) AS decision_quarter
   FROM daily_decisions
  ORDER BY decision_day DESC;
        WITH NO DATA;
        
        COMMENT ON MATERIALIZED VIEW view_decision_temporal_trends IS 
        '8 window functions with overlapping frames (7/30/90-day moving averages). Refresh: Daily at 02:00 UTC. Performance: 40% faster (3 seconds → 1.8 seconds).';
    </sql>
    <rollback>
        DROP MATERIALIZED VIEW IF EXISTS view_decision_temporal_trends CASCADE;
        
        CREATE VIEW public.view_decision_temporal_trends AS
 WITH daily_decisions AS (
         SELECT dd.made_public_date AS decision_day,
            count(*) AS daily_decisions,
            round(((100.0 * (count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%BIFALL%'::text) OR (upper((dpd.chamber)::text) ~~ '%GODKÄNT%'::text) OR (upper((dpd.chamber)::text) ~~ '%BIFALLA%'::text))))::numeric) / (NULLIF(count(*), 0))::numeric), 2) AS daily_approval_rate,
            count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%BIFALL%'::text) OR (upper((dpd.chamber)::text) ~~ '%GODKÄNT%'::text) OR (upper((dpd.chamber)::text) ~~ '%BIFALLA%'::text))) AS approved_decisions,
            count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%AVSLAG%'::text) OR (upper((dpd.chamber)::text) ~~ '%AVSLÅ%'::text))) AS rejected_decisions,
            count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%ÅTERFÖRVISNING%'::text) OR (upper((dpd.chamber)::text) ~~ '%ÅTERFÖRVISA%'::text))) AS referred_back_decisions,
            count(*) FILTER (WHERE ((upper((dpd.chamber)::text) ~~ '%UTSKOTT%'::text) AND (upper((dpd.chamber)::text) !~~ '%ÅTERFÖRVISNING%'::text))) AS committee_referral_decisions
           FROM (((public.document_proposal_data dpd
             JOIN public.document_proposal_container dpc ON ((dpc.proposal_document_proposal_c_0 = dpd.hjid)))
             JOIN public.document_status_container dsc ON ((dsc.document_proposal_document_s_0 = dpc.hjid)))
             JOIN public.document_data dd ON (((dd.id)::text = (dsc.document_document_status_con_0)::text)))
          WHERE ((dd.made_public_date IS NOT NULL) AND (dd.made_public_date &gt;= (CURRENT_DATE - '5 years'::interval)) AND (dpd.chamber IS NOT NULL) AND (length((dpd.chamber)::text) &gt;= 6) AND (length((dpd.chamber)::text) &lt;= 29))
          GROUP BY dd.made_public_date
        )
 SELECT decision_day,
    daily_decisions,
    daily_approval_rate,
    approved_decisions,
    rejected_decisions,
    referred_back_decisions,
    committee_referral_decisions,
    round(avg(daily_decisions) OVER (ORDER BY decision_day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW), 2) AS ma_7day_decisions,
    round(avg(daily_decisions) OVER (ORDER BY decision_day ROWS BETWEEN 29 PRECEDING AND CURRENT ROW), 2) AS ma_30day_decisions,
    round(avg(daily_decisions) OVER (ORDER BY decision_day ROWS BETWEEN 89 PRECEDING AND CURRENT ROW), 2) AS ma_90day_decisions,
    round(avg(daily_approval_rate) OVER (ORDER BY decision_day ROWS BETWEEN 29 PRECEDING AND CURRENT ROW), 2) AS ma_30day_approval_rate,
    lag(daily_decisions, 365) OVER (ORDER BY decision_day) AS decisions_last_year,
    (daily_decisions - lag(daily_decisions, 365) OVER (ORDER BY decision_day)) AS yoy_decisions_change,
    round(((100.0 * ((daily_decisions - lag(daily_decisions, 365) OVER (ORDER BY decision_day)))::numeric) / (NULLIF(lag(daily_decisions, 365) OVER (ORDER BY decision_day), 0))::numeric), 2) AS yoy_decisions_change_pct,
    EXTRACT(year FROM decision_day) AS decision_year,
    EXTRACT(month FROM decision_day) AS decision_month,
    EXTRACT(week FROM decision_day) AS decision_week,
    EXTRACT(dow FROM decision_day) AS decision_day_of_week,
        CASE
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(7)::numeric, (8)::numeric])) THEN 'Summer Recess'::text
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(12)::numeric, (1)::numeric])) THEN 'Winter Recess'::text
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(2)::numeric, (3)::numeric])) THEN 'Spring Session'::text
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(9)::numeric, (10)::numeric, (11)::numeric])) THEN 'Autumn Session'::text
            WHEN (EXTRACT(month FROM decision_day) = ANY (ARRAY[(4)::numeric, (5)::numeric, (6)::numeric])) THEN 'Late Spring Session'::text
            ELSE 'Active Session'::text
        END AS parliamentary_period,
    ((('Q'::text || (EXTRACT(quarter FROM decision_day))::text) || ' '::text) || (EXTRACT(year FROM decision_day))::text) AS decision_quarter
   FROM daily_decisions
  ORDER BY decision_day DESC;
    </rollback>
</changeSet>

<changeSet id="1.69-001-01-index-decision_temporal_day" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_decision_temporal_day"/>
        </not>
    </preConditions>
    <comment>Create index idx_decision_temporal_day on view_decision_temporal_trends for query optimization</comment>
    <createIndex indexName="idx_decision_temporal_day" tableName="view_decision_temporal_trends">
        <column name="decision_day" descending="true"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_decision_temporal_day" tableName="view_decision_temporal_trends"/>
    </rollback>
</changeSet>

<changeSet id="1.69-001-02-index-decision_temporal_quarter" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_decision_temporal_quarter"/>
        </not>
    </preConditions>
    <comment>Create index idx_decision_temporal_quarter on view_decision_temporal_trends for query optimization</comment>
    <createIndex indexName="idx_decision_temporal_quarter" tableName="view_decision_temporal_trends">
        <column name="decision_quarter"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_decision_temporal_quarter" tableName="view_decision_temporal_trends"/>
    </rollback>
</changeSet>

<!-- 
===================================================================================
 VIEW 2: view_riksdagen_politician_influence_metrics
 
 Issue: Network analysis with self-join on vote_data (O(n²) complexity)
 Current Performance: 5-15 seconds
 Target Performance: 1-3 seconds (80% improvement)
 Refresh Schedule: Weekly on Sunday at 03:00 UTC
===================================================================================
-->

<changeSet id="1.69-002-materialize-riksdagen_politician_influence_metrics" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <viewExists viewName="view_riksdagen_politician_influence_metrics"/>
        <sqlCheck expectedResult="0">
            SELECT COUNT(*) FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'view_riksdagen_politician_influence_metrics'
        </sqlCheck>
    </preConditions>
    <comment>
        Convert view_riksdagen_politician_influence_metrics to MATERIALIZED VIEW for 80% performance improvement.
        
        Issue: Network analysis with self-join on vote_data (O(n²) complexity)
        Current: 5-15 seconds
        Target: 1-3 seconds
        Refresh: Weekly on Sunday at 03:00 UTC
    </comment>
    <sql splitStatements="false">
        DROP VIEW IF EXISTS view_riksdagen_politician_influence_metrics CASCADE;
        
        CREATE MATERIALIZED VIEW view_riksdagen_politician_influence_metrics AS
 WITH co_voting_pairs AS (
         SELECT v1.embedded_id_intressent_id AS person_1,
            v2.embedded_id_intressent_id AS person_2,
            count(*) AS co_votes,
            sum(
                CASE
                    WHEN ((v1.vote)::text = (v2.vote)::text) THEN 1
                    ELSE 0
                END) AS aligned_votes,
            ((sum(
                CASE
                    WHEN ((v1.vote)::text = (v2.vote)::text) THEN 1
                    ELSE 0
                END))::double precision / (NULLIF(count(*), 0))::double precision) AS alignment_rate
           FROM (public.vote_data v1
             JOIN public.vote_data v2 ON ((((v1.embedded_id_ballot_id)::text = (v2.embedded_id_ballot_id)::text) AND ((v1.embedded_id_intressent_id)::text &lt; (v2.embedded_id_intressent_id)::text))))
          WHERE ((v1.vote_date &gt;= (CURRENT_DATE - '3 years'::interval)) AND (upper((v1.vote)::text) = ANY (ARRAY['JA'::text, 'NEJ'::text])) AND (upper((v2.vote)::text) = ANY (ARRAY['JA'::text, 'NEJ'::text])))
          GROUP BY v1.embedded_id_intressent_id, v2.embedded_id_intressent_id
         HAVING (count(*) &gt;= 10)
        ), network_connections AS (
         SELECT co_voting_pairs.person_1 AS person_id
           FROM co_voting_pairs
          WHERE (co_voting_pairs.alignment_rate &gt;= (0.7)::double precision)
        UNION ALL
         SELECT co_voting_pairs.person_2 AS person_id
           FROM co_voting_pairs
          WHERE (co_voting_pairs.alignment_rate &gt;= (0.7)::double precision)
        ), influence_metrics AS (
         SELECT network_connections.person_id,
            count(*) AS strong_connections
           FROM network_connections
          GROUP BY network_connections.person_id
        ), network_percentiles AS (
         SELECT percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((influence_metrics.strong_connections)::double precision)) AS p50,
            percentile_cont((0.75)::double precision) WITHIN GROUP (ORDER BY ((influence_metrics.strong_connections)::double precision)) AS p75,
            percentile_cont((0.9)::double precision) WITHIN GROUP (ORDER BY ((influence_metrics.strong_connections)::double precision)) AS p90
           FROM influence_metrics
        )
 SELECT p.id AS person_id,
    p.first_name,
    p.last_name,
    p.party,
    COALESCE(im.strong_connections, (0)::bigint) AS network_connections,
    round((( SELECT network_percentiles.p50
           FROM network_percentiles))::numeric, 2) AS network_median,
        CASE
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p90
               FROM network_percentiles)) THEN 'HIGHLY_INFLUENTIAL'::text
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p75
               FROM network_percentiles)) THEN 'INFLUENTIAL'::text
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p50
               FROM network_percentiles)) THEN 'MODERATELY_INFLUENTIAL'::text
            WHEN (COALESCE(im.strong_connections, (0)::bigint) > 0) THEN 'LIMITED_INFLUENCE'::text
            ELSE 'MINIMAL_INFLUENCE'::text
        END AS influence_classification,
        CASE
            WHEN (COALESCE(im.strong_connections, (0)::bigint) &gt;= 20) THEN 'STRONG_BROKER'::text
            WHEN (COALESCE(im.strong_connections, (0)::bigint) &gt;= 10) THEN 'MODERATE_BROKER'::text
            WHEN (COALESCE(im.strong_connections, (0)::bigint) &gt;= 5) THEN 'WEAK_BROKER'::text
            ELSE 'NON_BROKER'::text
        END AS broker_classification,
        CASE
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p90
               FROM network_percentiles)) THEN 'High influence - top 10% network connections'::text
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p75
               FROM network_percentiles)) THEN 'Notable influence - top 25% network centrality'::text
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p50
               FROM network_percentiles)) THEN 'Standard influence - above median engagement'::text
            WHEN (COALESCE(im.strong_connections, (0)::bigint) > 0) THEN 'Limited influence - below median connections'::text
            ELSE 'Minimal network influence detected'::text
        END AS influence_assessment
   FROM (public.person_data p
     LEFT JOIN influence_metrics im ON (((im.person_id)::text = (p.id)::text)))
  WHERE ((p.status)::text = ANY (ARRAY[('Tjänstgörande riksdagsledamot'::character varying)::text, ('Tjänstgörande ersättare'::character varying)::text, ('Tillgänglig ersättare'::character varying)::text]))
  ORDER BY COALESCE(im.strong_connections, (0)::bigint) DESC, p.last_name, p.first_name;
        WITH NO DATA;
        
        COMMENT ON MATERIALIZED VIEW view_riksdagen_politician_influence_metrics IS 
        'Network analysis with self-join on vote_data (O(n²) complexity). Refresh: Weekly on Sunday at 03:00 UTC. Performance: 80% faster (5-15 seconds → 1-3 seconds).';
    </sql>
    <rollback>
        DROP MATERIALIZED VIEW IF EXISTS view_riksdagen_politician_influence_metrics CASCADE;
        
        CREATE VIEW public.view_riksdagen_politician_influence_metrics AS
 WITH co_voting_pairs AS (
         SELECT v1.embedded_id_intressent_id AS person_1,
            v2.embedded_id_intressent_id AS person_2,
            count(*) AS co_votes,
            sum(
                CASE
                    WHEN ((v1.vote)::text = (v2.vote)::text) THEN 1
                    ELSE 0
                END) AS aligned_votes,
            ((sum(
                CASE
                    WHEN ((v1.vote)::text = (v2.vote)::text) THEN 1
                    ELSE 0
                END))::double precision / (NULLIF(count(*), 0))::double precision) AS alignment_rate
           FROM (public.vote_data v1
             JOIN public.vote_data v2 ON ((((v1.embedded_id_ballot_id)::text = (v2.embedded_id_ballot_id)::text) AND ((v1.embedded_id_intressent_id)::text &lt; (v2.embedded_id_intressent_id)::text))))
          WHERE ((v1.vote_date &gt;= (CURRENT_DATE - '3 years'::interval)) AND (upper((v1.vote)::text) = ANY (ARRAY['JA'::text, 'NEJ'::text])) AND (upper((v2.vote)::text) = ANY (ARRAY['JA'::text, 'NEJ'::text])))
          GROUP BY v1.embedded_id_intressent_id, v2.embedded_id_intressent_id
         HAVING (count(*) &gt;= 10)
        ), network_connections AS (
         SELECT co_voting_pairs.person_1 AS person_id
           FROM co_voting_pairs
          WHERE (co_voting_pairs.alignment_rate &gt;= (0.7)::double precision)
        UNION ALL
         SELECT co_voting_pairs.person_2 AS person_id
           FROM co_voting_pairs
          WHERE (co_voting_pairs.alignment_rate &gt;= (0.7)::double precision)
        ), influence_metrics AS (
         SELECT network_connections.person_id,
            count(*) AS strong_connections
           FROM network_connections
          GROUP BY network_connections.person_id
        ), network_percentiles AS (
         SELECT percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((influence_metrics.strong_connections)::double precision)) AS p50,
            percentile_cont((0.75)::double precision) WITHIN GROUP (ORDER BY ((influence_metrics.strong_connections)::double precision)) AS p75,
            percentile_cont((0.9)::double precision) WITHIN GROUP (ORDER BY ((influence_metrics.strong_connections)::double precision)) AS p90
           FROM influence_metrics
        )
 SELECT p.id AS person_id,
    p.first_name,
    p.last_name,
    p.party,
    COALESCE(im.strong_connections, (0)::bigint) AS network_connections,
    round((( SELECT network_percentiles.p50
           FROM network_percentiles))::numeric, 2) AS network_median,
        CASE
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p90
               FROM network_percentiles)) THEN 'HIGHLY_INFLUENTIAL'::text
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p75
               FROM network_percentiles)) THEN 'INFLUENTIAL'::text
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p50
               FROM network_percentiles)) THEN 'MODERATELY_INFLUENTIAL'::text
            WHEN (COALESCE(im.strong_connections, (0)::bigint) > 0) THEN 'LIMITED_INFLUENCE'::text
            ELSE 'MINIMAL_INFLUENCE'::text
        END AS influence_classification,
        CASE
            WHEN (COALESCE(im.strong_connections, (0)::bigint) &gt;= 20) THEN 'STRONG_BROKER'::text
            WHEN (COALESCE(im.strong_connections, (0)::bigint) &gt;= 10) THEN 'MODERATE_BROKER'::text
            WHEN (COALESCE(im.strong_connections, (0)::bigint) &gt;= 5) THEN 'WEAK_BROKER'::text
            ELSE 'NON_BROKER'::text
        END AS broker_classification,
        CASE
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p90
               FROM network_percentiles)) THEN 'High influence - top 10% network connections'::text
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p75
               FROM network_percentiles)) THEN 'Notable influence - top 25% network centrality'::text
            WHEN ((COALESCE(im.strong_connections, (0)::bigint))::double precision &gt;= ( SELECT network_percentiles.p50
               FROM network_percentiles)) THEN 'Standard influence - above median engagement'::text
            WHEN (COALESCE(im.strong_connections, (0)::bigint) > 0) THEN 'Limited influence - below median connections'::text
            ELSE 'Minimal network influence detected'::text
        END AS influence_assessment
   FROM (public.person_data p
     LEFT JOIN influence_metrics im ON (((im.person_id)::text = (p.id)::text)))
  WHERE ((p.status)::text = ANY (ARRAY[('Tjänstgörande riksdagsledamot'::character varying)::text, ('Tjänstgörande ersättare'::character varying)::text, ('Tillgänglig ersättare'::character varying)::text]))
  ORDER BY COALESCE(im.strong_connections, (0)::bigint) DESC, p.last_name, p.first_name;
    </rollback>
</changeSet>

<changeSet id="1.69-002-01-index-influence_person" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_influence_person"/>
        </not>
    </preConditions>
    <comment>Create index idx_influence_person on view_riksdagen_politician_influence_metrics for query optimization</comment>
    <createIndex indexName="idx_influence_person" tableName="view_riksdagen_politician_influence_metrics">
        <column name="person_id"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_influence_person" tableName="view_riksdagen_politician_influence_metrics"/>
    </rollback>
</changeSet>

<changeSet id="1.69-002-02-index-influence_score" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_influence_score"/>
        </not>
    </preConditions>
    <comment>Create index idx_influence_score on view_riksdagen_politician_influence_metrics for query optimization</comment>
    <createIndex indexName="idx_influence_score" tableName="view_riksdagen_politician_influence_metrics">
        <column name="network_connections" descending="true"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_influence_score" tableName="view_riksdagen_politician_influence_metrics"/>
    </rollback>
</changeSet>

<!-- 
===================================================================================
 VIEW 3: view_party_effectiveness_trends
 
 Issue: Multi-source aggregation (voting + documents + violations) with 5 windows
 Current Performance: 800ms-1.5s
 Target Performance: <800ms (50% improvement)
 Refresh Schedule: Quarterly on 1st at 05:00 UTC
===================================================================================
-->

<changeSet id="1.69-003-materialize-party_effectiveness_trends" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <viewExists viewName="view_party_effectiveness_trends"/>
        <sqlCheck expectedResult="0">
            SELECT COUNT(*) FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'view_party_effectiveness_trends'
        </sqlCheck>
    </preConditions>
    <comment>
        Convert view_party_effectiveness_trends to MATERIALIZED VIEW for 50% performance improvement.
        
        Issue: Multi-source aggregation (voting + documents + violations) with 5 windows
        Current: 800ms-1.5s
        Target: &lt;800ms
        Refresh: Quarterly on 1st at 05:00 UTC
    </comment>
    <sql splitStatements="false">
        DROP VIEW IF EXISTS view_party_effectiveness_trends CASCADE;
        
        CREATE MATERIALIZED VIEW view_party_effectiveness_trends AS
 WITH quarterly_party_voting AS (
         SELECT view_riksdagen_vote_data_ballot_politician_summary_daily.party,
            date_trunc('quarter'::text, (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date)::timestamp with time zone) AS period_start,
            count(DISTINCT view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_intressent_id) AS active_members,
            sum(view_riksdagen_vote_data_ballot_politician_summary_daily.number_ballots) AS total_ballots,
            sum(view_riksdagen_vote_data_ballot_politician_summary_daily.total_votes) AS total_votes,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_absent), 2) AS avg_absence_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.won_percentage), 2) AS avg_win_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.rebel_percentage), 2) AS avg_rebel_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_yes), 2) AS avg_yes_rate
           FROM public.view_riksdagen_vote_data_ballot_politician_summary_daily
          WHERE ((view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date &gt;= (CURRENT_DATE - '3 years'::interval)) AND (view_riksdagen_vote_data_ballot_politician_summary_daily.party IS NOT NULL))
          GROUP BY view_riksdagen_vote_data_ballot_politician_summary_daily.party, (date_trunc('quarter'::text, (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date)::timestamp with time zone))
        ), party_documents AS (
         SELECT view_riksdagen_politician_document.party_short_code AS party,
            date_trunc('quarter'::text, (view_riksdagen_politician_document.made_public_date)::timestamp with time zone) AS period_start,
            count(*) AS documents_produced,
            count(DISTINCT
                CASE
                    WHEN ((view_riksdagen_politician_document.document_type)::text = 'Motion'::text) THEN view_riksdagen_politician_document.doc_id
                    ELSE NULL::character varying
                END) AS motions_count,
            count(DISTINCT view_riksdagen_politician_document.person_reference_id) AS active_document_authors
           FROM public.view_riksdagen_politician_document
          WHERE ((view_riksdagen_politician_document.made_public_date &gt;= (CURRENT_DATE - '3 years'::interval)) AND (view_riksdagen_politician_document.party_short_code IS NOT NULL))
          GROUP BY view_riksdagen_politician_document.party_short_code, (date_trunc('quarter'::text, (view_riksdagen_politician_document.made_public_date)::timestamp with time zone))
        ), party_violations AS (
         SELECT pd.party,
            date_trunc('quarter'::text, rv.detected_date) AS period_start,
            count(DISTINCT rv.id) AS violation_count,
            count(DISTINCT rv.reference_id) AS members_with_violations
           FROM (public.rule_violation rv
             JOIN public.person_data pd ON (((rv.reference_id)::text = (pd.id)::text)))
          WHERE (((rv.resource_type)::text = 'POLITICIAN'::text) AND ((rv.status)::text = 'ACTIVE'::text) AND (rv.detected_date &gt;= (CURRENT_DATE - '3 years'::interval)) AND (pd.party IS NOT NULL))
          GROUP BY pd.party, (date_trunc('quarter'::text, rv.detected_date))
        ), trend_analysis AS (
         SELECT qpv.party,
            qpv.period_start,
            qpv.active_members,
            qpv.total_ballots,
            qpv.total_votes,
            qpv.avg_absence_rate,
            qpv.avg_win_rate,
            qpv.avg_rebel_rate,
            qpv.avg_yes_rate,
            COALESCE(pds.documents_produced, (0)::bigint) AS documents_produced,
            COALESCE(pds.motions_count, (0)::bigint) AS motions_count,
            COALESCE(pds.active_document_authors, (0)::bigint) AS active_document_authors,
            COALESCE(pvs.violation_count, (0)::bigint) AS violation_count,
            COALESCE(pvs.members_with_violations, (0)::bigint) AS members_with_violations,
            lag(qpv.avg_win_rate, 1) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start) AS prev_win_rate,
            lag(qpv.avg_absence_rate, 1) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start) AS prev_absence_rate,
            lag(qpv.active_members, 1) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start) AS prev_members,
            round(avg(qpv.avg_win_rate) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start ROWS BETWEEN 3 PRECEDING AND CURRENT ROW), 2) AS ma_4quarter_win_rate,
            round(avg(qpv.avg_absence_rate) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start ROWS BETWEEN 3 PRECEDING AND CURRENT ROW), 2) AS ma_4quarter_absence
           FROM ((quarterly_party_voting qpv
             LEFT JOIN party_documents pds ON (((qpv.party = (pds.party)::text) AND (qpv.period_start = pds.period_start))))
             LEFT JOIN party_violations pvs ON (((qpv.party = (pvs.party)::text) AND (qpv.period_start = pvs.period_start))))
        )
 SELECT party,
    period_start,
    (((period_start + '3 mons'::interval) - '1 day'::interval))::date AS period_end,
    EXTRACT(year FROM period_start) AS year,
    EXTRACT(quarter FROM period_start) AS quarter,
    active_members,
    total_ballots,
    total_votes,
    avg_absence_rate,
    avg_win_rate,
    avg_rebel_rate,
    avg_yes_rate,
    documents_produced,
    motions_count,
    active_document_authors,
    violation_count,
    members_with_violations,
    round((avg_win_rate - prev_win_rate), 2) AS win_rate_trend,
    round((avg_absence_rate - prev_absence_rate), 2) AS absence_trend,
    (active_members - prev_members) AS member_change,
    ma_4quarter_win_rate,
    ma_4quarter_absence,
    round(((documents_produced)::numeric / (NULLIF(active_members, 0))::numeric), 2) AS docs_per_member,
    round((total_votes / (NULLIF(active_members, 0))::numeric), 2) AS votes_per_member,
    round(((violation_count)::numeric / (NULLIF(active_members, 0))::numeric), 2) AS violations_per_member,
        CASE
            WHEN ((avg_win_rate &gt;= (75)::numeric) AND (avg_absence_rate &lt; (10)::numeric)) THEN 'HIGH_PERFORMANCE'::text
            WHEN ((avg_win_rate &gt;= (60)::numeric) AND (avg_absence_rate &lt; (15)::numeric)) THEN 'GOOD_PERFORMANCE'::text
            WHEN ((avg_win_rate &gt;= (45)::numeric) OR (avg_absence_rate &lt; (20)::numeric)) THEN 'MODERATE_PERFORMANCE'::text
            ELSE 'LOW_PERFORMANCE'::text
        END AS performance_level,
        CASE
            WHEN (documents_produced &gt;= 50) THEN 'HIGHLY_PRODUCTIVE'::text
            WHEN (documents_produced &gt;= 20) THEN 'PRODUCTIVE'::text
            WHEN (documents_produced &gt;= 10) THEN 'MODERATELY_PRODUCTIVE'::text
            ELSE 'LOW_PRODUCTIVITY'::text
        END AS productivity_level,
        CASE
            WHEN ((avg_win_rate &gt;= (70)::numeric) AND (avg_absence_rate &lt; (12)::numeric) AND (violation_count &lt;= 2)) THEN 'Strong organizational effectiveness'::text
            WHEN ((avg_win_rate &gt;= (55)::numeric) AND (avg_absence_rate &lt; (18)::numeric)) THEN 'Solid party performance'::text
            WHEN ((avg_absence_rate &gt;= (20)::numeric) OR (violation_count &gt;= 5)) THEN 'Performance concerns detected'::text
            ELSE 'Standard party operations'::text
        END AS effectiveness_assessment
   FROM trend_analysis
  ORDER BY party, period_start DESC;
        WITH NO DATA;
        
        COMMENT ON MATERIALIZED VIEW view_party_effectiveness_trends IS 
        'Multi-source aggregation (voting + documents + violations) with 5 windows. Refresh: Quarterly on 1st at 05:00 UTC. Performance: 50% faster (800ms-1.5s → &lt;800ms).';
    </sql>
    <rollback>
        DROP MATERIALIZED VIEW IF EXISTS view_party_effectiveness_trends CASCADE;
        
        CREATE VIEW public.view_party_effectiveness_trends AS
 WITH quarterly_party_voting AS (
         SELECT view_riksdagen_vote_data_ballot_politician_summary_daily.party,
            date_trunc('quarter'::text, (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date)::timestamp with time zone) AS period_start,
            count(DISTINCT view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_intressent_id) AS active_members,
            sum(view_riksdagen_vote_data_ballot_politician_summary_daily.number_ballots) AS total_ballots,
            sum(view_riksdagen_vote_data_ballot_politician_summary_daily.total_votes) AS total_votes,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_absent), 2) AS avg_absence_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.won_percentage), 2) AS avg_win_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.rebel_percentage), 2) AS avg_rebel_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_yes), 2) AS avg_yes_rate
           FROM public.view_riksdagen_vote_data_ballot_politician_summary_daily
          WHERE ((view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date &gt;= (CURRENT_DATE - '3 years'::interval)) AND (view_riksdagen_vote_data_ballot_politician_summary_daily.party IS NOT NULL))
          GROUP BY view_riksdagen_vote_data_ballot_politician_summary_daily.party, (date_trunc('quarter'::text, (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date)::timestamp with time zone))
        ), party_documents AS (
         SELECT view_riksdagen_politician_document.party_short_code AS party,
            date_trunc('quarter'::text, (view_riksdagen_politician_document.made_public_date)::timestamp with time zone) AS period_start,
            count(*) AS documents_produced,
            count(DISTINCT
                CASE
                    WHEN ((view_riksdagen_politician_document.document_type)::text = 'Motion'::text) THEN view_riksdagen_politician_document.doc_id
                    ELSE NULL::character varying
                END) AS motions_count,
            count(DISTINCT view_riksdagen_politician_document.person_reference_id) AS active_document_authors
           FROM public.view_riksdagen_politician_document
          WHERE ((view_riksdagen_politician_document.made_public_date &gt;= (CURRENT_DATE - '3 years'::interval)) AND (view_riksdagen_politician_document.party_short_code IS NOT NULL))
          GROUP BY view_riksdagen_politician_document.party_short_code, (date_trunc('quarter'::text, (view_riksdagen_politician_document.made_public_date)::timestamp with time zone))
        ), party_violations AS (
         SELECT pd.party,
            date_trunc('quarter'::text, rv.detected_date) AS period_start,
            count(DISTINCT rv.id) AS violation_count,
            count(DISTINCT rv.reference_id) AS members_with_violations
           FROM (public.rule_violation rv
             JOIN public.person_data pd ON (((rv.reference_id)::text = (pd.id)::text)))
          WHERE (((rv.resource_type)::text = 'POLITICIAN'::text) AND ((rv.status)::text = 'ACTIVE'::text) AND (rv.detected_date &gt;= (CURRENT_DATE - '3 years'::interval)) AND (pd.party IS NOT NULL))
          GROUP BY pd.party, (date_trunc('quarter'::text, rv.detected_date))
        ), trend_analysis AS (
         SELECT qpv.party,
            qpv.period_start,
            qpv.active_members,
            qpv.total_ballots,
            qpv.total_votes,
            qpv.avg_absence_rate,
            qpv.avg_win_rate,
            qpv.avg_rebel_rate,
            qpv.avg_yes_rate,
            COALESCE(pds.documents_produced, (0)::bigint) AS documents_produced,
            COALESCE(pds.motions_count, (0)::bigint) AS motions_count,
            COALESCE(pds.active_document_authors, (0)::bigint) AS active_document_authors,
            COALESCE(pvs.violation_count, (0)::bigint) AS violation_count,
            COALESCE(pvs.members_with_violations, (0)::bigint) AS members_with_violations,
            lag(qpv.avg_win_rate, 1) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start) AS prev_win_rate,
            lag(qpv.avg_absence_rate, 1) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start) AS prev_absence_rate,
            lag(qpv.active_members, 1) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start) AS prev_members,
            round(avg(qpv.avg_win_rate) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start ROWS BETWEEN 3 PRECEDING AND CURRENT ROW), 2) AS ma_4quarter_win_rate,
            round(avg(qpv.avg_absence_rate) OVER (PARTITION BY qpv.party ORDER BY qpv.period_start ROWS BETWEEN 3 PRECEDING AND CURRENT ROW), 2) AS ma_4quarter_absence
           FROM ((quarterly_party_voting qpv
             LEFT JOIN party_documents pds ON (((qpv.party = (pds.party)::text) AND (qpv.period_start = pds.period_start))))
             LEFT JOIN party_violations pvs ON (((qpv.party = (pvs.party)::text) AND (qpv.period_start = pvs.period_start))))
        )
 SELECT party,
    period_start,
    (((period_start + '3 mons'::interval) - '1 day'::interval))::date AS period_end,
    EXTRACT(year FROM period_start) AS year,
    EXTRACT(quarter FROM period_start) AS quarter,
    active_members,
    total_ballots,
    total_votes,
    avg_absence_rate,
    avg_win_rate,
    avg_rebel_rate,
    avg_yes_rate,
    documents_produced,
    motions_count,
    active_document_authors,
    violation_count,
    members_with_violations,
    round((avg_win_rate - prev_win_rate), 2) AS win_rate_trend,
    round((avg_absence_rate - prev_absence_rate), 2) AS absence_trend,
    (active_members - prev_members) AS member_change,
    ma_4quarter_win_rate,
    ma_4quarter_absence,
    round(((documents_produced)::numeric / (NULLIF(active_members, 0))::numeric), 2) AS docs_per_member,
    round((total_votes / (NULLIF(active_members, 0))::numeric), 2) AS votes_per_member,
    round(((violation_count)::numeric / (NULLIF(active_members, 0))::numeric), 2) AS violations_per_member,
        CASE
            WHEN ((avg_win_rate &gt;= (75)::numeric) AND (avg_absence_rate &lt; (10)::numeric)) THEN 'HIGH_PERFORMANCE'::text
            WHEN ((avg_win_rate &gt;= (60)::numeric) AND (avg_absence_rate &lt; (15)::numeric)) THEN 'GOOD_PERFORMANCE'::text
            WHEN ((avg_win_rate &gt;= (45)::numeric) OR (avg_absence_rate &lt; (20)::numeric)) THEN 'MODERATE_PERFORMANCE'::text
            ELSE 'LOW_PERFORMANCE'::text
        END AS performance_level,
        CASE
            WHEN (documents_produced &gt;= 50) THEN 'HIGHLY_PRODUCTIVE'::text
            WHEN (documents_produced &gt;= 20) THEN 'PRODUCTIVE'::text
            WHEN (documents_produced &gt;= 10) THEN 'MODERATELY_PRODUCTIVE'::text
            ELSE 'LOW_PRODUCTIVITY'::text
        END AS productivity_level,
        CASE
            WHEN ((avg_win_rate &gt;= (70)::numeric) AND (avg_absence_rate &lt; (12)::numeric) AND (violation_count &lt;= 2)) THEN 'Strong organizational effectiveness'::text
            WHEN ((avg_win_rate &gt;= (55)::numeric) AND (avg_absence_rate &lt; (18)::numeric)) THEN 'Solid party performance'::text
            WHEN ((avg_absence_rate &gt;= (20)::numeric) OR (violation_count &gt;= 5)) THEN 'Performance concerns detected'::text
            ELSE 'Standard party operations'::text
        END AS effectiveness_assessment
   FROM trend_analysis
  ORDER BY party, period_start DESC;
    </rollback>
</changeSet>

<changeSet id="1.69-003-01-index-effectiveness_party_period" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_effectiveness_party_period"/>
        </not>
    </preConditions>
    <comment>Create index idx_effectiveness_party_period on view_party_effectiveness_trends for query optimization</comment>
    <createIndex indexName="idx_effectiveness_party_period" tableName="view_party_effectiveness_trends">
        <column name="party"/>
        <column name="period_start" descending="true"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_effectiveness_party_period" tableName="view_party_effectiveness_trends"/>
    </rollback>
</changeSet>

<changeSet id="1.69-003-02-index-effectiveness_score" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_effectiveness_score"/>
        </not>
    </preConditions>
    <comment>Create index idx_effectiveness_score on view_party_effectiveness_trends for query optimization</comment>
    <createIndex indexName="idx_effectiveness_score" tableName="view_party_effectiveness_trends">
        <column name="performance_level" descending="true"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_effectiveness_score" tableName="view_party_effectiveness_trends"/>
    </rollback>
</changeSet>

<!-- 
===================================================================================
 VIEW 4: view_politician_behavioral_trends
 
 Issue: 7 window functions with LAG and 3-month moving averages
 Current Performance: 4 seconds
 Target Performance: 2.6 seconds (35% improvement)
 Refresh Schedule: Monthly on 1st at 04:00 UTC
===================================================================================
-->

<changeSet id="1.69-004-materialize-politician_behavioral_trends" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <viewExists viewName="view_politician_behavioral_trends"/>
        <sqlCheck expectedResult="0">
            SELECT COUNT(*) FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'view_politician_behavioral_trends'
        </sqlCheck>
    </preConditions>
    <comment>
        Convert view_politician_behavioral_trends to MATERIALIZED VIEW for 35% performance improvement.
        
        Issue: 7 window functions with LAG and 3-month moving averages
        Current: 4 seconds
        Target: 2.6 seconds
        Refresh: Monthly on 1st at 04:00 UTC
    </comment>
    <sql splitStatements="false">
        DROP VIEW IF EXISTS view_politician_behavioral_trends CASCADE;
        
        CREATE MATERIALIZED VIEW view_politician_behavioral_trends AS
 WITH monthly_voting_data AS (
         SELECT view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_intressent_id AS person_id,
            date_trunc('month'::text, (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date)::timestamp with time zone) AS period_start,
            max(view_riksdagen_vote_data_ballot_politician_summary_daily.first_name) AS first_name,
            max(view_riksdagen_vote_data_ballot_politician_summary_daily.last_name) AS last_name,
            max(view_riksdagen_vote_data_ballot_politician_summary_daily.party) AS party,
            sum(view_riksdagen_vote_data_ballot_politician_summary_daily.number_ballots) AS total_ballots,
            sum(view_riksdagen_vote_data_ballot_politician_summary_daily.total_votes) AS total_votes,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_absent), 2) AS avg_absence_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_yes), 2) AS avg_yes_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_no), 2) AS avg_no_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_abstain), 2) AS avg_abstain_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.won_percentage), 2) AS avg_win_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.rebel_percentage), 2) AS avg_rebel_rate
           FROM public.view_riksdagen_vote_data_ballot_politician_summary_daily
          WHERE (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date &gt;= (CURRENT_DATE - '3 years'::interval))
          GROUP BY view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_intressent_id, (date_trunc('month'::text, (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date)::timestamp with time zone))
        ), violation_counts AS (
         SELECT rule_violation.reference_id AS person_id,
            date_trunc('month'::text, rule_violation.detected_date) AS period_start,
            count(*) AS violation_count,
            count(DISTINCT rule_violation.rule_group) AS violation_types,
            max(rule_violation.detected_date) AS latest_violation_date
           FROM public.rule_violation
          WHERE (((rule_violation.resource_type)::text = 'POLITICIAN'::text) AND ((rule_violation.status)::text = 'ACTIVE'::text) AND (rule_violation.detected_date &gt;= (CURRENT_DATE - '3 years'::interval)))
          GROUP BY rule_violation.reference_id, (date_trunc('month'::text, rule_violation.detected_date))
        ), trend_calculations AS (
         SELECT mvd.person_id,
            mvd.period_start,
            mvd.first_name,
            mvd.last_name,
            mvd.party,
            mvd.total_ballots,
            mvd.total_votes,
            mvd.avg_absence_rate,
            mvd.avg_yes_rate,
            mvd.avg_no_rate,
            mvd.avg_abstain_rate,
            mvd.avg_win_rate,
            mvd.avg_rebel_rate,
            COALESCE(vc.violation_count, (0)::bigint) AS violation_count,
            COALESCE(vc.violation_types, (0)::bigint) AS violation_types,
            lag(mvd.avg_absence_rate, 1) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start) AS prev_absence_rate,
            lag(mvd.avg_win_rate, 1) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start) AS prev_win_rate,
            lag(mvd.avg_rebel_rate, 1) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start) AS prev_rebel_rate,
            round(avg(mvd.avg_absence_rate) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS ma_3month_absence,
            round(avg(mvd.avg_win_rate) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS ma_3month_win_rate,
            round(avg(mvd.avg_rebel_rate) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS ma_3month_rebel_rate
           FROM (monthly_voting_data mvd
             LEFT JOIN violation_counts vc ON ((((mvd.person_id)::text = (vc.person_id)::text) AND (mvd.period_start = vc.period_start))))
        )
 SELECT person_id,
    period_start,
    (((period_start + '1 mon'::interval) - '1 day'::interval))::date AS period_end,
    first_name,
    last_name,
    party,
    total_ballots,
    total_votes,
    avg_absence_rate,
    avg_yes_rate,
    avg_no_rate,
    avg_abstain_rate,
    avg_win_rate,
    avg_rebel_rate,
    violation_count,
    violation_types,
    round((avg_absence_rate - prev_absence_rate), 2) AS absence_trend,
    round((avg_win_rate - prev_win_rate), 2) AS win_rate_trend,
    round((avg_rebel_rate - prev_rebel_rate), 2) AS rebel_rate_trend,
    ma_3month_absence,
    ma_3month_win_rate,
    ma_3month_rebel_rate,
        CASE
            WHEN (avg_absence_rate &gt;= (30)::numeric) THEN 'HIGH_ABSENTEEISM'::text
            WHEN (avg_absence_rate &gt;= (15)::numeric) THEN 'MODERATE_ABSENTEEISM'::text
            WHEN (avg_absence_rate &gt;= (5)::numeric) THEN 'LOW_ABSENTEEISM'::text
            ELSE 'EXCELLENT_ATTENDANCE'::text
        END AS attendance_status,
        CASE
            WHEN (avg_win_rate &gt;= (80)::numeric) THEN 'HIGHLY_EFFECTIVE'::text
            WHEN (avg_win_rate &gt;= (60)::numeric) THEN 'EFFECTIVE'::text
            WHEN (avg_win_rate &gt;= (40)::numeric) THEN 'MODERATELY_EFFECTIVE'::text
            ELSE 'LOW_EFFECTIVENESS'::text
        END AS effectiveness_status,
        CASE
            WHEN (avg_rebel_rate &gt;= (20)::numeric) THEN 'HIGH_INDEPENDENCE'::text
            WHEN (avg_rebel_rate &gt;= (10)::numeric) THEN 'MODERATE_INDEPENDENCE'::text
            WHEN (avg_rebel_rate &gt;= (5)::numeric) THEN 'LOW_INDEPENDENCE'::text
            ELSE 'PARTY_LOYAL'::text
        END AS discipline_status,
        CASE
            WHEN ((avg_absence_rate &gt;= (30)::numeric) OR (avg_rebel_rate &gt;= (20)::numeric) OR (violation_count &gt;= 3)) THEN 'ELEVATED_RISK'::text
            WHEN ((avg_absence_rate &gt;= (15)::numeric) OR (avg_rebel_rate &gt;= (10)::numeric) OR (violation_count &gt;= 1)) THEN 'MODERATE_RISK'::text
            WHEN ((avg_win_rate &gt;= (70)::numeric) AND (avg_absence_rate &lt; (10)::numeric)) THEN 'HIGH_PERFORMER'::text
            ELSE 'STANDARD_BEHAVIOR'::text
        END AS behavioral_assessment
   FROM trend_calculations
  WHERE (total_ballots &gt;= (5)::numeric)
  ORDER BY person_id, period_start DESC;
        WITH NO DATA;
        
        COMMENT ON MATERIALIZED VIEW view_politician_behavioral_trends IS 
        '7 window functions with LAG and 3-month moving averages. Refresh: Monthly on 1st at 04:00 UTC. Performance: 35% faster (4 seconds → 2.6 seconds).';
    </sql>
    <rollback>
        DROP MATERIALIZED VIEW IF EXISTS view_politician_behavioral_trends CASCADE;
        
        CREATE VIEW public.view_politician_behavioral_trends AS
 WITH monthly_voting_data AS (
         SELECT view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_intressent_id AS person_id,
            date_trunc('month'::text, (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date)::timestamp with time zone) AS period_start,
            max(view_riksdagen_vote_data_ballot_politician_summary_daily.first_name) AS first_name,
            max(view_riksdagen_vote_data_ballot_politician_summary_daily.last_name) AS last_name,
            max(view_riksdagen_vote_data_ballot_politician_summary_daily.party) AS party,
            sum(view_riksdagen_vote_data_ballot_politician_summary_daily.number_ballots) AS total_ballots,
            sum(view_riksdagen_vote_data_ballot_politician_summary_daily.total_votes) AS total_votes,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_absent), 2) AS avg_absence_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_yes), 2) AS avg_yes_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_no), 2) AS avg_no_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.avg_percentage_abstain), 2) AS avg_abstain_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.won_percentage), 2) AS avg_win_rate,
            round(avg(view_riksdagen_vote_data_ballot_politician_summary_daily.rebel_percentage), 2) AS avg_rebel_rate
           FROM public.view_riksdagen_vote_data_ballot_politician_summary_daily
          WHERE (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date &gt;= (CURRENT_DATE - '3 years'::interval))
          GROUP BY view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_intressent_id, (date_trunc('month'::text, (view_riksdagen_vote_data_ballot_politician_summary_daily.embedded_id_vote_date)::timestamp with time zone))
        ), violation_counts AS (
         SELECT rule_violation.reference_id AS person_id,
            date_trunc('month'::text, rule_violation.detected_date) AS period_start,
            count(*) AS violation_count,
            count(DISTINCT rule_violation.rule_group) AS violation_types,
            max(rule_violation.detected_date) AS latest_violation_date
           FROM public.rule_violation
          WHERE (((rule_violation.resource_type)::text = 'POLITICIAN'::text) AND ((rule_violation.status)::text = 'ACTIVE'::text) AND (rule_violation.detected_date &gt;= (CURRENT_DATE - '3 years'::interval)))
          GROUP BY rule_violation.reference_id, (date_trunc('month'::text, rule_violation.detected_date))
        ), trend_calculations AS (
         SELECT mvd.person_id,
            mvd.period_start,
            mvd.first_name,
            mvd.last_name,
            mvd.party,
            mvd.total_ballots,
            mvd.total_votes,
            mvd.avg_absence_rate,
            mvd.avg_yes_rate,
            mvd.avg_no_rate,
            mvd.avg_abstain_rate,
            mvd.avg_win_rate,
            mvd.avg_rebel_rate,
            COALESCE(vc.violation_count, (0)::bigint) AS violation_count,
            COALESCE(vc.violation_types, (0)::bigint) AS violation_types,
            lag(mvd.avg_absence_rate, 1) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start) AS prev_absence_rate,
            lag(mvd.avg_win_rate, 1) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start) AS prev_win_rate,
            lag(mvd.avg_rebel_rate, 1) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start) AS prev_rebel_rate,
            round(avg(mvd.avg_absence_rate) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS ma_3month_absence,
            round(avg(mvd.avg_win_rate) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS ma_3month_win_rate,
            round(avg(mvd.avg_rebel_rate) OVER (PARTITION BY mvd.person_id ORDER BY mvd.period_start ROWS BETWEEN 2 PRECEDING AND CURRENT ROW), 2) AS ma_3month_rebel_rate
           FROM (monthly_voting_data mvd
             LEFT JOIN violation_counts vc ON ((((mvd.person_id)::text = (vc.person_id)::text) AND (mvd.period_start = vc.period_start))))
        )
 SELECT person_id,
    period_start,
    (((period_start + '1 mon'::interval) - '1 day'::interval))::date AS period_end,
    first_name,
    last_name,
    party,
    total_ballots,
    total_votes,
    avg_absence_rate,
    avg_yes_rate,
    avg_no_rate,
    avg_abstain_rate,
    avg_win_rate,
    avg_rebel_rate,
    violation_count,
    violation_types,
    round((avg_absence_rate - prev_absence_rate), 2) AS absence_trend,
    round((avg_win_rate - prev_win_rate), 2) AS win_rate_trend,
    round((avg_rebel_rate - prev_rebel_rate), 2) AS rebel_rate_trend,
    ma_3month_absence,
    ma_3month_win_rate,
    ma_3month_rebel_rate,
        CASE
            WHEN (avg_absence_rate &gt;= (30)::numeric) THEN 'HIGH_ABSENTEEISM'::text
            WHEN (avg_absence_rate &gt;= (15)::numeric) THEN 'MODERATE_ABSENTEEISM'::text
            WHEN (avg_absence_rate &gt;= (5)::numeric) THEN 'LOW_ABSENTEEISM'::text
            ELSE 'EXCELLENT_ATTENDANCE'::text
        END AS attendance_status,
        CASE
            WHEN (avg_win_rate &gt;= (80)::numeric) THEN 'HIGHLY_EFFECTIVE'::text
            WHEN (avg_win_rate &gt;= (60)::numeric) THEN 'EFFECTIVE'::text
            WHEN (avg_win_rate &gt;= (40)::numeric) THEN 'MODERATELY_EFFECTIVE'::text
            ELSE 'LOW_EFFECTIVENESS'::text
        END AS effectiveness_status,
        CASE
            WHEN (avg_rebel_rate &gt;= (20)::numeric) THEN 'HIGH_INDEPENDENCE'::text
            WHEN (avg_rebel_rate &gt;= (10)::numeric) THEN 'MODERATE_INDEPENDENCE'::text
            WHEN (avg_rebel_rate &gt;= (5)::numeric) THEN 'LOW_INDEPENDENCE'::text
            ELSE 'PARTY_LOYAL'::text
        END AS discipline_status,
        CASE
            WHEN ((avg_absence_rate &gt;= (30)::numeric) OR (avg_rebel_rate &gt;= (20)::numeric) OR (violation_count &gt;= 3)) THEN 'ELEVATED_RISK'::text
            WHEN ((avg_absence_rate &gt;= (15)::numeric) OR (avg_rebel_rate &gt;= (10)::numeric) OR (violation_count &gt;= 1)) THEN 'MODERATE_RISK'::text
            WHEN ((avg_win_rate &gt;= (70)::numeric) AND (avg_absence_rate &lt; (10)::numeric)) THEN 'HIGH_PERFORMER'::text
            ELSE 'STANDARD_BEHAVIOR'::text
        END AS behavioral_assessment
   FROM trend_calculations
  WHERE (total_ballots &gt;= (5)::numeric)
  ORDER BY person_id, period_start DESC;
    </rollback>
</changeSet>

<changeSet id="1.69-004-01-index-behavioral_person_period" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_behavioral_person_period"/>
        </not>
    </preConditions>
    <comment>Create index idx_behavioral_person_period on view_politician_behavioral_trends for query optimization</comment>
    <createIndex indexName="idx_behavioral_person_period" tableName="view_politician_behavioral_trends">
        <column name="person_id"/>
        <column name="period_start" descending="true"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_behavioral_person_period" tableName="view_politician_behavioral_trends"/>
    </rollback>
</changeSet>

<changeSet id="1.69-004-02-index-behavioral_trend_score" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_behavioral_trend_score"/>
        </not>
    </preConditions>
    <comment>Create index idx_behavioral_trend_score on view_politician_behavioral_trends for query optimization</comment>
    <createIndex indexName="idx_behavioral_trend_score" tableName="view_politician_behavioral_trends">
        <column name="behavioral_assessment" descending="true"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_behavioral_trend_score" tableName="view_politician_behavioral_trends"/>
    </rollback>
</changeSet>

<!-- 
===================================================================================
 VIEW 5: view_election_cycle_temporal_trends
 
 Issue: 6 CTEs with 5 JOINs, complex temporal aggregation
 Current Performance: 5-10 seconds
 Target Performance: <3 seconds (70% improvement)
 Refresh Schedule: Post-election (manual trigger)
===================================================================================
-->

<changeSet id="1.69-005-materialize-election_cycle_temporal_trends" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <viewExists viewName="view_election_cycle_temporal_trends"/>
        <sqlCheck expectedResult="0">
            SELECT COUNT(*) FROM pg_matviews WHERE schemaname = 'public' AND matviewname = 'view_election_cycle_temporal_trends'
        </sqlCheck>
    </preConditions>
    <comment>
        Convert view_election_cycle_temporal_trends to MATERIALIZED VIEW for 70% performance improvement.
        
        Issue: 6 CTEs with 5 JOINs, complex temporal aggregation
        Current: 5-10 seconds
        Target: &lt;3 seconds
        Refresh: Post-election (manual trigger)
    </comment>
    <sql splitStatements="false">
        DROP VIEW IF EXISTS view_election_cycle_temporal_trends CASCADE;
        
        CREATE MATERIALIZED VIEW view_election_cycle_temporal_trends AS
 WITH v151_base AS (
         WITH election_cycle_calendar AS (
                 SELECT year_series.year_series AS calendar_year,
                    (((1994)::numeric + (floor((((year_series.year_series - 1994))::numeric / 4.0)) * (4)::numeric)))::integer AS cycle_start_year,
                    ((((1994)::numeric + (floor((((year_series.year_series - 1994))::numeric / 4.0)) * (4)::numeric)) + (4)::numeric))::integer AS cycle_end_year
                   FROM generate_series(1994, ((EXTRACT(year FROM CURRENT_DATE))::integer + 4), 1) year_series(year_series)
                ), election_cycle_periods AS (
                 SELECT election_cycle_calendar.calendar_year,
                    election_cycle_calendar.cycle_start_year,
                    election_cycle_calendar.cycle_end_year,
                    ((election_cycle_calendar.cycle_start_year || '-'::text) || election_cycle_calendar.cycle_end_year) AS election_cycle_id,
                    ((election_cycle_calendar.calendar_year - election_cycle_calendar.cycle_start_year) + 1) AS cycle_year,
                    make_date(election_cycle_calendar.calendar_year, 9, 1) AS autumn_start,
                    make_date((election_cycle_calendar.calendar_year + 1), 1, 25) AS autumn_end,
                    make_date(election_cycle_calendar.calendar_year, 1, 26) AS spring_start,
                    make_date(election_cycle_calendar.calendar_year, 8, 31) AS spring_end,
                        CASE
                            WHEN (((election_cycle_calendar.calendar_year - election_cycle_calendar.cycle_start_year) + 1) = 4) THEN true
                            ELSE false
                        END AS is_election_year
                   FROM election_cycle_calendar
                ), temporal_data_autumn AS (
                 SELECT ecp.election_cycle_id,
                    ecp.cycle_year,
                    ecp.calendar_year,
                    'autumn'::text AS semester,
                    false AS is_pre_election_semester,
                    (((EXTRACT(year FROM age((make_date(ecp.cycle_end_year, 9, 15))::timestamp with time zone, (ecp.autumn_start)::timestamp with time zone)))::integer * 12) + (EXTRACT(month FROM age((make_date(ecp.cycle_end_year, 9, 15))::timestamp with time zone, (ecp.autumn_start)::timestamp with time zone)))::integer) AS months_until_election,
                    count(DISTINCT pbt.person_id) AS active_politicians,
                    round(avg(((100)::numeric - pbt.avg_absence_rate)), 2) AS avg_attendance_rate,
                    sum(pbt.total_ballots) AS total_ballots,
                    sum(pbt.total_votes) AS total_votes,
                    round(avg(pbt.avg_win_rate), 2) AS avg_win_rate,
                    round(avg(pbt.avg_rebel_rate), 2) AS avg_rebel_rate,
                    sum(pbt.violation_count) AS violation_count,
                    round(avg(pbt.ma_3month_absence), 2) AS avg_ma_absence,
                    round(avg(dtt.daily_approval_rate), 2) AS avg_approval_rate,
                    sum(dtt.daily_decisions) AS total_decisions,
                    round(avg(cp.productivity_score), 2) AS avg_committee_productivity
                   FROM (((election_cycle_periods ecp
                     LEFT JOIN public.view_politician_behavioral_trends pbt ON (((pbt.period_start &gt;= ecp.autumn_start) AND (pbt.period_start &lt;= ecp.autumn_end))))
                     LEFT JOIN public.view_decision_temporal_trends dtt ON (((dtt.decision_day &gt;= ecp.autumn_start) AND (dtt.decision_day &lt;= ecp.autumn_end))))
                     LEFT JOIN public.view_committee_productivity cp ON ((1 = 1)))
                  GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, ecp.autumn_start, ecp.cycle_end_year
                ), temporal_data_spring AS (
                 SELECT ecp.election_cycle_id,
                    ecp.cycle_year,
                    ecp.calendar_year,
                    'spring'::text AS semester,
                        CASE
                            WHEN ecp.is_election_year THEN true
                            ELSE false
                        END AS is_pre_election_semester,
                    (((EXTRACT(year FROM age((make_date(ecp.cycle_end_year, 9, 15))::timestamp with time zone, (ecp.spring_start)::timestamp with time zone)))::integer * 12) + (EXTRACT(month FROM age((make_date(ecp.cycle_end_year, 9, 15))::timestamp with time zone, (ecp.spring_start)::timestamp with time zone)))::integer) AS months_until_election,
                    count(DISTINCT pbt.person_id) AS active_politicians,
                    round(avg(((100)::numeric - pbt.avg_absence_rate)), 2) AS avg_attendance_rate,
                    sum(pbt.total_ballots) AS total_ballots,
                    sum(pbt.total_votes) AS total_votes,
                    round(avg(pbt.avg_win_rate), 2) AS avg_win_rate,
                    round(avg(pbt.avg_rebel_rate), 2) AS avg_rebel_rate,
                    sum(pbt.violation_count) AS violation_count,
                    round(avg(pbt.ma_3month_absence), 2) AS avg_ma_absence,
                    round(avg(dtt.daily_approval_rate), 2) AS avg_approval_rate,
                    sum(dtt.daily_decisions) AS total_decisions,
                    round(avg(cp.productivity_score), 2) AS avg_committee_productivity
                   FROM (((election_cycle_periods ecp
                     LEFT JOIN public.view_politician_behavioral_trends pbt ON (((pbt.period_start &gt;= ecp.spring_start) AND (pbt.period_start &lt;= ecp.spring_end))))
                     LEFT JOIN public.view_decision_temporal_trends dtt ON (((dtt.decision_day &gt;= ecp.spring_start) AND (dtt.decision_day &lt;= ecp.spring_end))))
                     LEFT JOIN public.view_committee_productivity cp ON ((1 = 1)))
                  GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, ecp.spring_start, ecp.cycle_end_year, ecp.is_election_year
                )
         SELECT temporal_data_autumn.election_cycle_id,
            temporal_data_autumn.cycle_year,
            temporal_data_autumn.calendar_year,
            temporal_data_autumn.semester,
            temporal_data_autumn.is_pre_election_semester,
            temporal_data_autumn.months_until_election,
            temporal_data_autumn.active_politicians,
            temporal_data_autumn.avg_attendance_rate,
            temporal_data_autumn.total_ballots,
            temporal_data_autumn.total_votes,
            temporal_data_autumn.avg_win_rate,
            temporal_data_autumn.avg_rebel_rate,
            temporal_data_autumn.violation_count,
            temporal_data_autumn.avg_ma_absence,
            temporal_data_autumn.avg_approval_rate,
            temporal_data_autumn.total_decisions,
            temporal_data_autumn.avg_committee_productivity
           FROM temporal_data_autumn
        UNION ALL
         SELECT temporal_data_spring.election_cycle_id,
            temporal_data_spring.cycle_year,
            temporal_data_spring.calendar_year,
            temporal_data_spring.semester,
            temporal_data_spring.is_pre_election_semester,
            temporal_data_spring.months_until_election,
            temporal_data_spring.active_politicians,
            temporal_data_spring.avg_attendance_rate,
            temporal_data_spring.total_ballots,
            temporal_data_spring.total_votes,
            temporal_data_spring.avg_win_rate,
            temporal_data_spring.avg_rebel_rate,
            temporal_data_spring.violation_count,
            temporal_data_spring.avg_ma_absence,
            temporal_data_spring.avg_approval_rate,
            temporal_data_spring.total_decisions,
            temporal_data_spring.avg_committee_productivity
           FROM temporal_data_spring
  ORDER BY 1, 2, 4
        ), windowed AS (
         SELECT v.election_cycle_id,
            v.cycle_year,
            v.calendar_year,
            v.semester,
            v.is_pre_election_semester,
            v.months_until_election,
            v.active_politicians,
            v.avg_attendance_rate,
            v.total_ballots,
            v.total_votes,
            v.avg_win_rate,
            v.avg_rebel_rate,
            v.violation_count,
            v.avg_ma_absence,
            v.avg_approval_rate,
            v.total_decisions,
            v.avg_committee_productivity,
            rank() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_attendance_rate DESC NULLS LAST) AS rank_by_attendance,
            percent_rank() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_attendance_rate DESC NULLS LAST) AS percent_rank_attendance,
            ntile(4) OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_attendance_rate DESC NULLS LAST) AS ntile_performance,
            lag(v.avg_attendance_rate) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS prev_semester_attendance,
            lag(v.total_decisions) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS prev_semester_decisions,
            lead(v.avg_attendance_rate) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS next_semester_attendance,
            stddev_pop(v.avg_attendance_rate) OVER (PARTITION BY v.election_cycle_id) AS stddev_attendance,
            stddev_pop(v.avg_win_rate) OVER (PARTITION BY v.election_cycle_id) AS stddev_win_rate,
            stddev_pop(v.total_decisions) OVER (PARTITION BY v.election_cycle_id) AS stddev_decisions
           FROM v151_base v
        )
 SELECT election_cycle_id,
    cycle_year,
    calendar_year,
    semester,
    is_pre_election_semester,
    months_until_election,
    active_politicians,
    avg_attendance_rate,
    total_ballots,
    total_votes,
    avg_win_rate,
    avg_rebel_rate,
    violation_count,
    avg_ma_absence,
    avg_approval_rate,
    total_decisions,
    avg_committee_productivity,
    rank_by_attendance,
    percent_rank_attendance,
    ntile_performance,
    prev_semester_attendance,
    prev_semester_decisions,
    next_semester_attendance,
    stddev_attendance,
    stddev_win_rate,
    stddev_decisions,
        CASE
            WHEN ((prev_semester_attendance IS NOT NULL) AND (prev_semester_attendance > (0)::numeric)) THEN round((((avg_attendance_rate - prev_semester_attendance) / prev_semester_attendance) * (100)::numeric), 2)
            ELSE NULL::numeric
        END AS change_attendance_pct,
        CASE
            WHEN ((prev_semester_decisions IS NOT NULL) AND (prev_semester_decisions > (0)::numeric)) THEN round((((total_decisions - prev_semester_decisions) / prev_semester_decisions) * (100)::numeric), 2)
            ELSE NULL::numeric
        END AS change_decisions_pct,
        CASE
            WHEN (prev_semester_attendance IS NULL) THEN 'baseline'::text
            WHEN (avg_attendance_rate > (prev_semester_attendance + (5)::numeric)) THEN 'improving'::text
            WHEN (avg_attendance_rate &lt; (prev_semester_attendance - (5)::numeric)) THEN 'declining'::text
            ELSE 'stable'::text
        END AS attendance_trend,
        CASE
            WHEN ((avg_attendance_rate IS NOT NULL) AND (avg_win_rate IS NOT NULL)) THEN round(((avg_attendance_rate * 0.5) + (avg_win_rate * 0.5)), 2)
            ELSE NULL::numeric
        END AS overall_performance_score,
        CASE
            WHEN (stddev_attendance > (10)::numeric) THEN 'high_volatility'::text
            WHEN (stddev_attendance > (5)::numeric) THEN 'moderate_volatility'::text
            ELSE 'stable'::text
        END AS volatility_assessment,
        CASE
            WHEN ((next_semester_attendance IS NOT NULL) AND (next_semester_attendance > (avg_attendance_rate + (5)::numeric))) THEN 'expected_improvement'::text
            WHEN ((next_semester_attendance IS NOT NULL) AND (next_semester_attendance &lt; (avg_attendance_rate - (5)::numeric))) THEN 'expected_decline'::text
            ELSE 'stable_forecast'::text
        END AS forecast_trend
   FROM windowed w;
        WITH NO DATA;
        
        COMMENT ON MATERIALIZED VIEW view_election_cycle_temporal_trends IS 
        '6 CTEs with 5 JOINs, complex temporal aggregation. Refresh: Post-election (manual trigger). Performance: 70% faster (5-10 seconds → &lt;3 seconds).';
    </sql>
    <rollback>
        DROP MATERIALIZED VIEW IF EXISTS view_election_cycle_temporal_trends CASCADE;
        
        CREATE VIEW public.view_election_cycle_temporal_trends AS
 WITH v151_base AS (
         WITH election_cycle_calendar AS (
                 SELECT year_series.year_series AS calendar_year,
                    (((1994)::numeric + (floor((((year_series.year_series - 1994))::numeric / 4.0)) * (4)::numeric)))::integer AS cycle_start_year,
                    ((((1994)::numeric + (floor((((year_series.year_series - 1994))::numeric / 4.0)) * (4)::numeric)) + (4)::numeric))::integer AS cycle_end_year
                   FROM generate_series(1994, ((EXTRACT(year FROM CURRENT_DATE))::integer + 4), 1) year_series(year_series)
                ), election_cycle_periods AS (
                 SELECT election_cycle_calendar.calendar_year,
                    election_cycle_calendar.cycle_start_year,
                    election_cycle_calendar.cycle_end_year,
                    ((election_cycle_calendar.cycle_start_year || '-'::text) || election_cycle_calendar.cycle_end_year) AS election_cycle_id,
                    ((election_cycle_calendar.calendar_year - election_cycle_calendar.cycle_start_year) + 1) AS cycle_year,
                    make_date(election_cycle_calendar.calendar_year, 9, 1) AS autumn_start,
                    make_date((election_cycle_calendar.calendar_year + 1), 1, 25) AS autumn_end,
                    make_date(election_cycle_calendar.calendar_year, 1, 26) AS spring_start,
                    make_date(election_cycle_calendar.calendar_year, 8, 31) AS spring_end,
                        CASE
                            WHEN (((election_cycle_calendar.calendar_year - election_cycle_calendar.cycle_start_year) + 1) = 4) THEN true
                            ELSE false
                        END AS is_election_year
                   FROM election_cycle_calendar
                ), temporal_data_autumn AS (
                 SELECT ecp.election_cycle_id,
                    ecp.cycle_year,
                    ecp.calendar_year,
                    'autumn'::text AS semester,
                    false AS is_pre_election_semester,
                    (((EXTRACT(year FROM age((make_date(ecp.cycle_end_year, 9, 15))::timestamp with time zone, (ecp.autumn_start)::timestamp with time zone)))::integer * 12) + (EXTRACT(month FROM age((make_date(ecp.cycle_end_year, 9, 15))::timestamp with time zone, (ecp.autumn_start)::timestamp with time zone)))::integer) AS months_until_election,
                    count(DISTINCT pbt.person_id) AS active_politicians,
                    round(avg(((100)::numeric - pbt.avg_absence_rate)), 2) AS avg_attendance_rate,
                    sum(pbt.total_ballots) AS total_ballots,
                    sum(pbt.total_votes) AS total_votes,
                    round(avg(pbt.avg_win_rate), 2) AS avg_win_rate,
                    round(avg(pbt.avg_rebel_rate), 2) AS avg_rebel_rate,
                    sum(pbt.violation_count) AS violation_count,
                    round(avg(pbt.ma_3month_absence), 2) AS avg_ma_absence,
                    round(avg(dtt.daily_approval_rate), 2) AS avg_approval_rate,
                    sum(dtt.daily_decisions) AS total_decisions,
                    round(avg(cp.productivity_score), 2) AS avg_committee_productivity
                   FROM (((election_cycle_periods ecp
                     LEFT JOIN public.view_politician_behavioral_trends pbt ON (((pbt.period_start &gt;= ecp.autumn_start) AND (pbt.period_start &lt;= ecp.autumn_end))))
                     LEFT JOIN public.view_decision_temporal_trends dtt ON (((dtt.decision_day &gt;= ecp.autumn_start) AND (dtt.decision_day &lt;= ecp.autumn_end))))
                     LEFT JOIN public.view_committee_productivity cp ON ((1 = 1)))
                  GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, ecp.autumn_start, ecp.cycle_end_year
                ), temporal_data_spring AS (
                 SELECT ecp.election_cycle_id,
                    ecp.cycle_year,
                    ecp.calendar_year,
                    'spring'::text AS semester,
                        CASE
                            WHEN ecp.is_election_year THEN true
                            ELSE false
                        END AS is_pre_election_semester,
                    (((EXTRACT(year FROM age((make_date(ecp.cycle_end_year, 9, 15))::timestamp with time zone, (ecp.spring_start)::timestamp with time zone)))::integer * 12) + (EXTRACT(month FROM age((make_date(ecp.cycle_end_year, 9, 15))::timestamp with time zone, (ecp.spring_start)::timestamp with time zone)))::integer) AS months_until_election,
                    count(DISTINCT pbt.person_id) AS active_politicians,
                    round(avg(((100)::numeric - pbt.avg_absence_rate)), 2) AS avg_attendance_rate,
                    sum(pbt.total_ballots) AS total_ballots,
                    sum(pbt.total_votes) AS total_votes,
                    round(avg(pbt.avg_win_rate), 2) AS avg_win_rate,
                    round(avg(pbt.avg_rebel_rate), 2) AS avg_rebel_rate,
                    sum(pbt.violation_count) AS violation_count,
                    round(avg(pbt.ma_3month_absence), 2) AS avg_ma_absence,
                    round(avg(dtt.daily_approval_rate), 2) AS avg_approval_rate,
                    sum(dtt.daily_decisions) AS total_decisions,
                    round(avg(cp.productivity_score), 2) AS avg_committee_productivity
                   FROM (((election_cycle_periods ecp
                     LEFT JOIN public.view_politician_behavioral_trends pbt ON (((pbt.period_start &gt;= ecp.spring_start) AND (pbt.period_start &lt;= ecp.spring_end))))
                     LEFT JOIN public.view_decision_temporal_trends dtt ON (((dtt.decision_day &gt;= ecp.spring_start) AND (dtt.decision_day &lt;= ecp.spring_end))))
                     LEFT JOIN public.view_committee_productivity cp ON ((1 = 1)))
                  GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, ecp.spring_start, ecp.cycle_end_year, ecp.is_election_year
                )
         SELECT temporal_data_autumn.election_cycle_id,
            temporal_data_autumn.cycle_year,
            temporal_data_autumn.calendar_year,
            temporal_data_autumn.semester,
            temporal_data_autumn.is_pre_election_semester,
            temporal_data_autumn.months_until_election,
            temporal_data_autumn.active_politicians,
            temporal_data_autumn.avg_attendance_rate,
            temporal_data_autumn.total_ballots,
            temporal_data_autumn.total_votes,
            temporal_data_autumn.avg_win_rate,
            temporal_data_autumn.avg_rebel_rate,
            temporal_data_autumn.violation_count,
            temporal_data_autumn.avg_ma_absence,
            temporal_data_autumn.avg_approval_rate,
            temporal_data_autumn.total_decisions,
            temporal_data_autumn.avg_committee_productivity
           FROM temporal_data_autumn
        UNION ALL
         SELECT temporal_data_spring.election_cycle_id,
            temporal_data_spring.cycle_year,
            temporal_data_spring.calendar_year,
            temporal_data_spring.semester,
            temporal_data_spring.is_pre_election_semester,
            temporal_data_spring.months_until_election,
            temporal_data_spring.active_politicians,
            temporal_data_spring.avg_attendance_rate,
            temporal_data_spring.total_ballots,
            temporal_data_spring.total_votes,
            temporal_data_spring.avg_win_rate,
            temporal_data_spring.avg_rebel_rate,
            temporal_data_spring.violation_count,
            temporal_data_spring.avg_ma_absence,
            temporal_data_spring.avg_approval_rate,
            temporal_data_spring.total_decisions,
            temporal_data_spring.avg_committee_productivity
           FROM temporal_data_spring
  ORDER BY 1, 2, 4
        ), windowed AS (
         SELECT v.election_cycle_id,
            v.cycle_year,
            v.calendar_year,
            v.semester,
            v.is_pre_election_semester,
            v.months_until_election,
            v.active_politicians,
            v.avg_attendance_rate,
            v.total_ballots,
            v.total_votes,
            v.avg_win_rate,
            v.avg_rebel_rate,
            v.violation_count,
            v.avg_ma_absence,
            v.avg_approval_rate,
            v.total_decisions,
            v.avg_committee_productivity,
            rank() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_attendance_rate DESC NULLS LAST) AS rank_by_attendance,
            percent_rank() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_attendance_rate DESC NULLS LAST) AS percent_rank_attendance,
            ntile(4) OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_attendance_rate DESC NULLS LAST) AS ntile_performance,
            lag(v.avg_attendance_rate) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS prev_semester_attendance,
            lag(v.total_decisions) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS prev_semester_decisions,
            lead(v.avg_attendance_rate) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS next_semester_attendance,
            stddev_pop(v.avg_attendance_rate) OVER (PARTITION BY v.election_cycle_id) AS stddev_attendance,
            stddev_pop(v.avg_win_rate) OVER (PARTITION BY v.election_cycle_id) AS stddev_win_rate,
            stddev_pop(v.total_decisions) OVER (PARTITION BY v.election_cycle_id) AS stddev_decisions
           FROM v151_base v
        )
 SELECT election_cycle_id,
    cycle_year,
    calendar_year,
    semester,
    is_pre_election_semester,
    months_until_election,
    active_politicians,
    avg_attendance_rate,
    total_ballots,
    total_votes,
    avg_win_rate,
    avg_rebel_rate,
    violation_count,
    avg_ma_absence,
    avg_approval_rate,
    total_decisions,
    avg_committee_productivity,
    rank_by_attendance,
    percent_rank_attendance,
    ntile_performance,
    prev_semester_attendance,
    prev_semester_decisions,
    next_semester_attendance,
    stddev_attendance,
    stddev_win_rate,
    stddev_decisions,
        CASE
            WHEN ((prev_semester_attendance IS NOT NULL) AND (prev_semester_attendance > (0)::numeric)) THEN round((((avg_attendance_rate - prev_semester_attendance) / prev_semester_attendance) * (100)::numeric), 2)
            ELSE NULL::numeric
        END AS change_attendance_pct,
        CASE
            WHEN ((prev_semester_decisions IS NOT NULL) AND (prev_semester_decisions > (0)::numeric)) THEN round((((total_decisions - prev_semester_decisions) / prev_semester_decisions) * (100)::numeric), 2)
            ELSE NULL::numeric
        END AS change_decisions_pct,
        CASE
            WHEN (prev_semester_attendance IS NULL) THEN 'baseline'::text
            WHEN (avg_attendance_rate > (prev_semester_attendance + (5)::numeric)) THEN 'improving'::text
            WHEN (avg_attendance_rate &lt; (prev_semester_attendance - (5)::numeric)) THEN 'declining'::text
            ELSE 'stable'::text
        END AS attendance_trend,
        CASE
            WHEN ((avg_attendance_rate IS NOT NULL) AND (avg_win_rate IS NOT NULL)) THEN round(((avg_attendance_rate * 0.5) + (avg_win_rate * 0.5)), 2)
            ELSE NULL::numeric
        END AS overall_performance_score,
        CASE
            WHEN (stddev_attendance > (10)::numeric) THEN 'high_volatility'::text
            WHEN (stddev_attendance > (5)::numeric) THEN 'moderate_volatility'::text
            ELSE 'stable'::text
        END AS volatility_assessment,
        CASE
            WHEN ((next_semester_attendance IS NOT NULL) AND (next_semester_attendance > (avg_attendance_rate + (5)::numeric))) THEN 'expected_improvement'::text
            WHEN ((next_semester_attendance IS NOT NULL) AND (next_semester_attendance &lt; (avg_attendance_rate - (5)::numeric))) THEN 'expected_decline'::text
            ELSE 'stable_forecast'::text
        END AS forecast_trend
   FROM windowed w;
    </rollback>
</changeSet>

<changeSet id="1.69-005-01-index-election_temporal_cycle" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_election_temporal_cycle"/>
        </not>
    </preConditions>
    <comment>Create index idx_election_temporal_cycle on view_election_cycle_temporal_trends for query optimization</comment>
    <createIndex indexName="idx_election_temporal_cycle" tableName="view_election_cycle_temporal_trends">
        <column name="election_cycle_id"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_election_temporal_cycle" tableName="view_election_cycle_temporal_trends"/>
    </rollback>
</changeSet>

<changeSet id="1.69-005-02-index-election_temporal_year" author="performance-engineer">
    <preConditions onFail="MARK_RAN">
        <not>
            <indexExists indexName="idx_election_temporal_year"/>
        </not>
    </preConditions>
    <comment>Create index idx_election_temporal_year on view_election_cycle_temporal_trends for query optimization</comment>
    <createIndex indexName="idx_election_temporal_year" tableName="view_election_cycle_temporal_trends">
        <column name="calendar_year" descending="true"/>
    </createIndex>
    <rollback>
        <dropIndex indexName="idx_election_temporal_year" tableName="view_election_cycle_temporal_trends"/>
    </rollback>
</changeSet>

</databaseChangeLog>

