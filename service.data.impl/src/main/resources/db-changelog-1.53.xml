<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.6.xsd">

<!-- 
  Party Longitudinal Analysis Views - Database Changelog v1.53 (ENHANCED)
  Author: Intelligence Operative & Political Analyst
  Date: 2026-01-15
  GitHub Issue: #8209 - Party Performance Across Election Cycles - Longitudinal Analysis (2002-2026)
  Dependencies: #8208 (Election Cycle Views v1.51), #8218 (Statistical Enhancements v1.52)
  
  ENHANCEMENTS (Based on PR #8218 review feedback):
  - Advanced statistical functions: RANK, PERCENT_RANK, NTILE, LAG, LEAD, STDDEV_POP
  - Swedish parliament cycle structure: autumn/spring semesters (not calendar years)
  - Multi-dimensional trend detection with volatility assessment
  - Predictive indicators and forecast trends
  - Enhanced comparative analysis with percentile rankings
  
  Purpose:
  Creates 3 comprehensive database views tracking party performance metrics across all
  election cycles (2002-2026), using Swedish parliamentary semester structure and advanced
  statistical analysis for sophisticated longitudinal intelligence.
  
  Swedish Parliamentary Context:
  - Election cycles: 2002-2005, 2006-2009, 2010-2013, 2014-2017, 2018-2021, 2022-2025, 2026-2029
  - Semester structure:
    * Autumn semester: September 1 - January 25 (election campaigns in cycle year 4)
    * Spring semester: January 26 - August 31 (pre-election in year 4)
  - 8 major parties: S, M, SD, C, V, KD, L, MP
  
  Advanced Statistical Features:
  1. RANK/PERCENT_RANK: Compare parties within each cycle/semester
  2. NTILE: Quartile-based performance tiers
  3. LAG/LEAD: Temporal trend detection (previous/next semester)
  4. STDDEV_POP: Volatility and consistency measurement
  5. Change percentages: Period-over-period growth rates
  6. Composite scores: Multi-metric aggregations
  
  Views Created (All with advanced statistics):
  1. view_riksdagen_party_longitudinal_performance - Semester-level metrics with rankings
  2. view_riksdagen_party_coalition_evolution - Alliance shifts with strength trends
  3. view_riksdagen_party_electoral_trends - Seat evolution with growth forecasting
-->

<changeSet id="1.53-intro" author="intelligence-operative">
    <comment>
        Database Changelog v1.53 (ENHANCED) - Party Longitudinal Analysis with Advanced Statistics
        
        Creates 3 views tracking party performance using Swedish parliament cycles
        (autumn/spring semesters) and advanced statistical functions (RANK, PERCENT_RANK,
        NTILE, LAG, LEAD, STDDEV_POP) for sophisticated longitudinal intelligence.
        
        Based on PR #8218 review feedback: "much more advanced views using advanced statistical
        functions... should follow swedish parliament cycles, not normal years"
    </comment>
    
    <sql>
        SELECT 
            'v1.53-enhanced' AS version,
            'Party longitudinal analysis with advanced statistics and semester structure' AS description,
            'RANK, PERCENT_RANK, NTILE, LAG, LEAD, STDDEV_POP' AS statistical_functions,
            'Autumn/Spring semesters (Swedish parliament cycles)' AS temporal_structure,
            CURRENT_TIMESTAMP AS applied_at;
    </sql>
</changeSet>


<!-- ========================================================================= -->
<!-- 1. PARTY LONGITUDINAL PERFORMANCE (ENHANCED WITH ADVANCED STATISTICS)   -->
<!-- ========================================================================= -->

<changeSet author="intelligence-operative" id="1.53-drop-party-performance" failOnError="false">
    <sql>DROP VIEW IF EXISTS view_riksdagen_party_longitudinal_performance CASCADE;</sql>
</changeSet>

<changeSet author="intelligence-operative" id="1.53-party-longitudinal-001" failOnError="true">
    <comment>
        Party Longitudinal Performance View (2002-2026) - ENHANCED
        
        Framework: Comparative Analysis (26 supporting views, 15+ risk rules)
        
        ENHANCEMENTS:
        - Swedish parliament semester structure (autumn: Sep-Jan, spring: Jan-Aug)
        - RANK: Party ranking within each cycle/semester by performance
        - PERCENT_RANK: Percentile ranking (0.0-1.0) for comparative analysis
        - NTILE(4): Quartile-based performance tiers
        - LAG/LEAD: Previous/next semester metrics for trend detection
        - STDDEV_POP: Volatility measurement across parties in each semester
        - Change percentages: Period-over-period growth rates
        - Composite performance score: Multi-metric aggregation
        - Volatility assessment: Stability classification
        - Forecast trends: Predictive indicators based on LEAD values
        
        Tracks 7 core metrics per party per semester:
        1. Total ballots participated in
        2. Active members count
        3. Win rate (% ballots won)
        4. Party discipline (% voting with party line)
        5. Documents authored
        6. Average rebel rate
        7. Leadership positions held
    </comment>
    
    <createView viewName="view_riksdagen_party_longitudinal_performance">
        <![CDATA[
WITH election_cycle_calendar AS (
    -- Swedish election cycles with semester structure
    SELECT 
        year_series AS calendar_year,
        CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2002
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2006
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2010
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2014
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2018
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2022
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2026
            ELSE NULL
        END AS election_year,
        (year_series - CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2002
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2006
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2010
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2014
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2018
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2022
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2026
        END + 1) AS cycle_year
    FROM generate_series(2002, EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER + 4, 1) AS year_series
    WHERE year_series >= 2002
),
election_cycle_periods AS (
    SELECT 
        calendar_year,
        election_year,
        cycle_year,
        (election_year || '-' || (election_year + 3)) AS election_cycle_id,
        MAKE_DATE(calendar_year, 9, 1) AS autumn_start,
        MAKE_DATE(calendar_year + 1, 1, 25) AS autumn_end,
        MAKE_DATE(calendar_year, 1, 26) AS spring_start,
        MAKE_DATE(calendar_year, 8, 31) AS spring_end,
        CASE WHEN cycle_year = 4 THEN TRUE ELSE FALSE END AS is_election_year
    FROM election_cycle_calendar
    WHERE election_year IS NOT NULL
),
party_semester_autumn AS (
    -- Autumn semester metrics (September - January)
    SELECT 
        ecp.election_cycle_id,
        ecp.cycle_year,
        ecp.calendar_year,
        'autumn' AS semester,
        ecp.is_election_year,
        vd.party,
        COUNT(DISTINCT vd.embedded_id_ballot_id) AS total_ballots,
        COUNT(DISTINCT vd.intressent_id) AS active_members,
        ROUND((COUNT(CASE WHEN vd.vote = 'Ja' AND vd.won = TRUE THEN 1 END)::NUMERIC / 
               NULLIF(COUNT(DISTINCT vd.embedded_id_ballot_id), 0) * 100), 2) AS win_rate,
        COUNT(DISTINCT dd.id) AS documents_authored,
        ROUND(AVG(CASE 
            WHEN vd.vote != (
                SELECT mode() WITHIN GROUP (ORDER BY vd2.vote)
                FROM vote_data vd2
                WHERE vd2.embedded_id_ballot_id = vd.embedded_id_ballot_id
                  AND vd2.party = vd.party
                  AND vd2.vote IN ('Ja', 'Nej', 'Avstår')
            ) AND vd.vote IN ('Ja', 'Nej', 'Avstår') THEN 100.0 
            ELSE 0.0 
        END), 2) AS avg_rebel_rate,
        COUNT(DISTINCT CASE WHEN ad.role_code IN ('Ordförande', 'Vice ordförande') THEN ad.id END) AS leadership_count
    FROM election_cycle_periods ecp
    JOIN vote_data vd ON vd.vote_date BETWEEN ecp.autumn_start AND ecp.autumn_end
    LEFT JOIN person_data pd ON pd.id = vd.intressent_id
    LEFT JOIN document_data dd ON dd.person_reference_id = pd.id 
                               AND dd.made_public_date BETWEEN ecp.autumn_start AND ecp.autumn_end
    LEFT JOIN assignment_data ad ON ad.intressent_id = pd.id
                                 AND ((ad.from_date BETWEEN ecp.autumn_start AND ecp.autumn_end)
                                   OR (ad.to_date BETWEEN ecp.autumn_start AND ecp.autumn_end)
                                   OR (ad.from_date <= ecp.autumn_start AND (ad.to_date IS NULL OR ad.to_date >= ecp.autumn_end)))
    WHERE vd.party IS NOT NULL
    GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, ecp.is_election_year, vd.party
),
party_semester_spring AS (
    -- Spring semester metrics (January - August)
    SELECT 
        ecp.election_cycle_id,
        ecp.cycle_year,
        ecp.calendar_year,
        'spring' AS semester,
        ecp.is_election_year,
        vd.party,
        COUNT(DISTINCT vd.embedded_id_ballot_id) AS total_ballots,
        COUNT(DISTINCT vd.intressent_id) AS active_members,
        ROUND((COUNT(CASE WHEN vd.vote = 'Ja' AND vd.won = TRUE THEN 1 END)::NUMERIC / 
               NULLIF(COUNT(DISTINCT vd.embedded_id_ballot_id), 0) * 100), 2) AS win_rate,
        COUNT(DISTINCT dd.id) AS documents_authored,
        ROUND(AVG(CASE 
            WHEN vd.vote != (
                SELECT mode() WITHIN GROUP (ORDER BY vd2.vote)
                FROM vote_data vd2
                WHERE vd2.embedded_id_ballot_id = vd.embedded_id_ballot_id
                  AND vd2.party = vd.party
                  AND vd2.vote IN ('Ja', 'Nej', 'Avstår')
            ) AND vd.vote IN ('Ja', 'Nej', 'Avstår') THEN 100.0 
            ELSE 0.0 
        END), 2) AS avg_rebel_rate,
        COUNT(DISTINCT CASE WHEN ad.role_code IN ('Ordförande', 'Vice ordförande') THEN ad.id END) AS leadership_count
    FROM election_cycle_periods ecp
    JOIN vote_data vd ON vd.vote_date BETWEEN ecp.spring_start AND ecp.spring_end
    LEFT JOIN person_data pd ON pd.id = vd.intressent_id
    LEFT JOIN document_data dd ON dd.person_reference_id = pd.id 
                               AND dd.made_public_date BETWEEN ecp.spring_start AND ecp.spring_end
    LEFT JOIN assignment_data ad ON ad.intressent_id = pd.id
                                 AND ((ad.from_date BETWEEN ecp.spring_start AND ecp.spring_end)
                                   OR (ad.to_date BETWEEN ecp.spring_start AND ecp.spring_end)
                                   OR (ad.from_date <= ecp.spring_start AND (ad.to_date IS NULL OR ad.to_date >= ecp.spring_end)))
    WHERE vd.party IS NOT NULL
    GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, ecp.is_election_year, vd.party
),
base_metrics AS (
    SELECT * FROM party_semester_autumn
    UNION ALL
    SELECT * FROM party_semester_spring
),
windowed_statistics AS (
    -- Apply advanced statistical window functions
    SELECT 
        bm.*,
        -- RANK: Party ranking within each cycle/semester
        RANK() OVER (PARTITION BY bm.election_cycle_id, bm.semester ORDER BY bm.win_rate DESC NULLS LAST) AS rank_by_win_rate,
        RANK() OVER (PARTITION BY bm.election_cycle_id, bm.semester ORDER BY bm.active_members DESC NULLS LAST) AS rank_by_members,
        RANK() OVER (PARTITION BY bm.election_cycle_id, bm.semester ORDER BY bm.avg_rebel_rate ASC NULLS LAST) AS rank_by_discipline,
        
        -- PERCENT_RANK: Percentile ranking (0.0 = worst, 1.0 = best)
        PERCENT_RANK() OVER (PARTITION BY bm.election_cycle_id, bm.semester ORDER BY bm.win_rate DESC NULLS LAST) AS percent_rank_win_rate,
        PERCENT_RANK() OVER (PARTITION BY bm.election_cycle_id, bm.semester ORDER BY bm.documents_authored DESC NULLS LAST) AS percent_rank_documents,
        
        -- NTILE: Quartile-based performance tiers (1=top 25%, 4=bottom 25%)
        NTILE(4) OVER (PARTITION BY bm.election_cycle_id, bm.semester ORDER BY bm.win_rate DESC NULLS LAST) AS ntile_performance,
        
        -- LAG: Previous semester metrics for trend detection
        LAG(bm.win_rate) OVER (PARTITION BY bm.party ORDER BY bm.election_cycle_id, bm.cycle_year, bm.semester) AS prev_semester_win_rate,
        LAG(bm.active_members) OVER (PARTITION BY bm.party ORDER BY bm.election_cycle_id, bm.cycle_year, bm.semester) AS prev_semester_members,
        LAG(bm.documents_authored) OVER (PARTITION BY bm.party ORDER BY bm.election_cycle_id, bm.cycle_year, bm.semester) AS prev_semester_documents,
        
        -- LEAD: Next semester metrics for predictive analysis
        LEAD(bm.win_rate) OVER (PARTITION BY bm.party ORDER BY bm.election_cycle_id, bm.cycle_year, bm.semester) AS next_semester_win_rate,
        LEAD(bm.active_members) OVER (PARTITION BY bm.party ORDER BY bm.election_cycle_id, bm.cycle_year, bm.semester) AS next_semester_members,
        
        -- STDDEV_POP: Volatility measurement across parties in each semester
        STDDEV_POP(bm.win_rate) OVER (PARTITION BY bm.election_cycle_id, bm.semester) AS stddev_win_rate,
        STDDEV_POP(bm.active_members) OVER (PARTITION BY bm.election_cycle_id, bm.semester) AS stddev_members,
        STDDEV_POP(bm.documents_authored) OVER (PARTITION BY bm.election_cycle_id, bm.semester) AS stddev_documents
    FROM base_metrics bm
)
SELECT 
    ws.*,
    -- Change percentages: Period-over-period growth rates
    CASE WHEN ws.prev_semester_win_rate IS NOT NULL AND ws.prev_semester_win_rate > 0 
         THEN ROUND(((ws.win_rate - ws.prev_semester_win_rate) / ws.prev_semester_win_rate * 100)::NUMERIC, 2)
         ELSE NULL END AS win_rate_change_pct,
    CASE WHEN ws.prev_semester_members IS NOT NULL AND ws.prev_semester_members > 0 
         THEN ROUND(((ws.active_members - ws.prev_semester_members)::NUMERIC / ws.prev_semester_members * 100)::NUMERIC, 2)
         ELSE NULL END AS members_change_pct,
    CASE WHEN ws.prev_semester_documents IS NOT NULL AND ws.prev_semester_documents > 0 
         THEN ROUND(((ws.documents_authored - ws.prev_semester_documents)::NUMERIC / ws.prev_semester_documents * 100)::NUMERIC, 2)
         ELSE NULL END AS documents_change_pct,
    
    -- Trajectory classification based on LAG/LEAD pattern matching
    CASE 
        WHEN ws.prev_semester_win_rate IS NULL THEN 'BASELINE'
        WHEN ws.win_rate > ws.prev_semester_win_rate + 5 AND (ws.next_semester_win_rate IS NULL OR ws.next_semester_win_rate > ws.win_rate) THEN 'ASCENDING'
        WHEN ws.win_rate < ws.prev_semester_win_rate - 5 AND (ws.next_semester_win_rate IS NULL OR ws.next_semester_win_rate < ws.win_rate) THEN 'DESCENDING'
        WHEN ws.win_rate > ws.prev_semester_win_rate + 5 THEN 'RECOVERING'
        WHEN ws.win_rate < ws.prev_semester_win_rate - 5 THEN 'DECLINING'
        ELSE 'STABLE'
    END AS trajectory,
    
    -- Composite performance score (weighted average)
    CASE WHEN ws.win_rate IS NOT NULL AND ws.active_members IS NOT NULL
         THEN ROUND((ws.win_rate * 0.4 + 
                     (ws.active_members::NUMERIC / NULLIF((MAX(ws.active_members) OVER (PARTITION BY ws.election_cycle_id, ws.semester)), 0) * 100) * 0.3 +
                     (ws.documents_authored::NUMERIC / NULLIF((MAX(ws.documents_authored) OVER (PARTITION BY ws.election_cycle_id, ws.semester)), 0) * 100) * 0.3)::NUMERIC, 2)
         ELSE NULL END AS composite_performance_score,
    
    -- Volatility assessment based on STDDEV
    CASE 
        WHEN ws.stddev_win_rate > 10 THEN 'HIGH_VOLATILITY'
        WHEN ws.stddev_win_rate > 5 THEN 'MODERATE_VOLATILITY'
        ELSE 'LOW_VOLATILITY'
    END AS volatility_assessment,
    
    -- Forecast trends based on LEAD values
    CASE 
        WHEN ws.next_semester_win_rate IS NULL THEN 'NO_FORECAST'
        WHEN ws.next_semester_win_rate > ws.win_rate + 5 THEN 'EXPECTED_IMPROVEMENT'
        WHEN ws.next_semester_win_rate < ws.win_rate - 5 THEN 'EXPECTED_DECLINE'
        ELSE 'EXPECTED_STABLE'
    END AS forecast_trend,
    
    -- Performance tier classification (based on percentile rank)
    CASE 
        WHEN ws.percent_rank_win_rate >= 0.75 THEN 'TOP_TIER'
        WHEN ws.percent_rank_win_rate >= 0.50 THEN 'UPPER_MID_TIER'
        WHEN ws.percent_rank_win_rate >= 0.25 THEN 'LOWER_MID_TIER'
        ELSE 'BOTTOM_TIER'
    END AS performance_tier,
    
    -- Momentum indicator (comparing change rate to volatility)
    CASE 
        WHEN ws.prev_semester_win_rate IS NOT NULL AND ws.stddev_win_rate > 0
        THEN ROUND(((ws.win_rate - ws.prev_semester_win_rate) / NULLIF(ws.stddev_win_rate, 0))::NUMERIC, 2)
        ELSE NULL 
    END AS momentum_z_score,
    
    -- Election cycle context flags
    CASE WHEN ws.semester = 'spring' AND ws.is_election_year THEN TRUE ELSE FALSE END AS is_pre_election_spring,
    CASE WHEN ws.semester = 'autumn' AND ws.is_election_year THEN TRUE ELSE FALSE END AS is_election_autumn
    
FROM windowed_statistics ws
ORDER BY ws.party, ws.election_cycle_id, ws.cycle_year, ws.semester;
        ]]>
    </createView>
    
    <rollback>
        <dropView viewName="view_riksdagen_party_longitudinal_performance"/>
    </rollback>
</changeSet>


<!-- ========================================================================= -->
<!-- 2. PARTY COALITION EVOLUTION (ENHANCED WITH ADVANCED STATISTICS)         -->
<!-- ========================================================================= -->

<changeSet author="intelligence-operative" id="1.53-drop-coalition-evolution" failOnError="false">
    <sql>DROP VIEW IF EXISTS view_riksdagen_party_coalition_evolution CASCADE;</sql>
</changeSet>

<changeSet author="intelligence-operative" id="1.53-party-coalition-002" failOnError="true">
    <comment>
        Party Coalition Evolution View (2002-2026) - ENHANCED
        
        Framework: Comparative Analysis, Network Analysis
        
        ENHANCEMENTS:
        - Swedish parliament semester structure (autumn/spring)
        - RANK: Coalition strength ranking within each semester
        - PERCENT_RANK: Percentile-based coalition comparison
        - NTILE: Coalition quartiles (strong/moderate/weak/opposition)
        - LAG/LEAD: Previous/next semester alignment for trend detection
        - STDDEV_POP: Alliance volatility measurement
        - Change percentages: Alignment rate changes over time
        - Strategic shift detection with statistical significance
        
        Tracks voting alignment between party pairs across election cycles.
        Alignment Rate = (aligned votes / total joint votes) * 100
        Where aligned = both parties vote Ja/Ja or Nej/Nej
    </comment>
    
    <createView viewName="view_riksdagen_party_coalition_evolution">
        <![CDATA[
WITH election_cycle_periods AS (
    SELECT 
        year_series AS calendar_year,
        CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2002
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2006
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2010
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2014
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2018
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2022
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2026
        END AS election_year,
        (year_series - CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2002
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2006
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2010
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2014
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2018
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2022
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2026
        END + 1) AS cycle_year,
        (CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2002
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2006
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2010
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2014
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2018
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2022
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2026
        END || '-' || (CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2005
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2009
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2013
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2017
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2021
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2025
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2029
        END)) AS election_cycle_id,
        MAKE_DATE(year_series, 9, 1) AS autumn_start,
        MAKE_DATE(year_series + 1, 1, 25) AS autumn_end,
        MAKE_DATE(year_series, 1, 26) AS spring_start,
        MAKE_DATE(year_series, 8, 31) AS spring_end
    FROM generate_series(2002, EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER + 4, 1) AS year_series
    WHERE year_series >= 2002
),
coalition_autumn AS (
    SELECT 
        ecp.election_cycle_id,
        ecp.cycle_year,
        ecp.calendar_year,
        'autumn' AS semester,
        vd1.party AS party_1,
        vd2.party AS party_2,
        COUNT(DISTINCT vd1.embedded_id_ballot_id) AS joint_votes,
        COUNT(DISTINCT CASE WHEN vd1.vote = vd2.vote AND vd1.vote IN ('Ja', 'Nej') THEN vd1.embedded_id_ballot_id END) AS aligned_votes,
        ROUND((COUNT(DISTINCT CASE WHEN vd1.vote = vd2.vote AND vd1.vote IN ('Ja', 'Nej') THEN vd1.embedded_id_ballot_id END)::NUMERIC / 
               NULLIF(COUNT(DISTINCT vd1.embedded_id_ballot_id), 0) * 100), 2) AS alignment_rate
    FROM election_cycle_periods ecp
    JOIN vote_data vd1 ON vd1.vote_date BETWEEN ecp.autumn_start AND ecp.autumn_end
    JOIN vote_data vd2 ON vd2.embedded_id_ballot_id = vd1.embedded_id_ballot_id
                       AND vd2.vote_date BETWEEN ecp.autumn_start AND ecp.autumn_end
    WHERE vd1.party IS NOT NULL 
      AND vd2.party IS NOT NULL
      AND vd1.party < vd2.party
      AND vd1.vote IN ('Ja', 'Nej')
      AND vd2.vote IN ('Ja', 'Nej')
      AND ecp.election_year IS NOT NULL
    GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, vd1.party, vd2.party
    HAVING COUNT(DISTINCT vd1.embedded_id_ballot_id) >= 10
),
coalition_spring AS (
    SELECT 
        ecp.election_cycle_id,
        ecp.cycle_year,
        ecp.calendar_year,
        'spring' AS semester,
        vd1.party AS party_1,
        vd2.party AS party_2,
        COUNT(DISTINCT vd1.embedded_id_ballot_id) AS joint_votes,
        COUNT(DISTINCT CASE WHEN vd1.vote = vd2.vote AND vd1.vote IN ('Ja', 'Nej') THEN vd1.embedded_id_ballot_id END) AS aligned_votes,
        ROUND((COUNT(DISTINCT CASE WHEN vd1.vote = vd2.vote AND vd1.vote IN ('Ja', 'Nej') THEN vd1.embedded_id_ballot_id END)::NUMERIC / 
               NULLIF(COUNT(DISTINCT vd1.embedded_id_ballot_id), 0) * 100), 2) AS alignment_rate
    FROM election_cycle_periods ecp
    JOIN vote_data vd1 ON vd1.vote_date BETWEEN ecp.spring_start AND ecp.spring_end
    JOIN vote_data vd2 ON vd2.embedded_id_ballot_id = vd1.embedded_id_ballot_id
                       AND vd2.vote_date BETWEEN ecp.spring_start AND ecp.spring_end
    WHERE vd1.party IS NOT NULL 
      AND vd2.party IS NOT NULL
      AND vd1.party < vd2.party
      AND vd1.vote IN ('Ja', 'Nej')
      AND vd2.vote IN ('Ja', 'Nej')
      AND ecp.election_year IS NOT NULL
    GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, vd1.party, vd2.party
    HAVING COUNT(DISTINCT vd1.embedded_id_ballot_id) >= 10
),
base_coalitions AS (
    SELECT * FROM coalition_autumn
    UNION ALL
    SELECT * FROM coalition_spring
),
windowed_statistics AS (
    SELECT 
        bc.*,
        -- RANK: Coalition strength ranking within each semester
        RANK() OVER (PARTITION BY bc.election_cycle_id, bc.semester ORDER BY bc.alignment_rate DESC NULLS LAST) AS rank_by_alignment,
        
        -- PERCENT_RANK: Percentile-based coalition comparison
        PERCENT_RANK() OVER (PARTITION BY bc.election_cycle_id, bc.semester ORDER BY bc.alignment_rate DESC NULLS LAST) AS percent_rank_alignment,
        
        -- NTILE: Coalition quartiles
        NTILE(4) OVER (PARTITION BY bc.election_cycle_id, bc.semester ORDER BY bc.alignment_rate DESC NULLS LAST) AS ntile_coalition_strength,
        
        -- LAG: Previous semester alignment for trend detection
        LAG(bc.alignment_rate) OVER (PARTITION BY bc.party_1, bc.party_2 ORDER BY bc.election_cycle_id, bc.cycle_year, bc.semester) AS prev_semester_alignment,
        LAG(bc.joint_votes) OVER (PARTITION BY bc.party_1, bc.party_2 ORDER BY bc.election_cycle_id, bc.cycle_year, bc.semester) AS prev_semester_joint_votes,
        
        -- LEAD: Next semester alignment for predictive analysis
        LEAD(bc.alignment_rate) OVER (PARTITION BY bc.party_1, bc.party_2 ORDER BY bc.election_cycle_id, bc.cycle_year, bc.semester) AS next_semester_alignment,
        
        -- STDDEV_POP: Alliance volatility measurement
        STDDEV_POP(bc.alignment_rate) OVER (PARTITION BY bc.election_cycle_id, bc.semester) AS stddev_alignment,
        STDDEV_POP(bc.alignment_rate) OVER (PARTITION BY bc.party_1, bc.party_2) AS stddev_party_pair
    FROM base_coalitions bc
)
SELECT 
    ws.*,
    -- Change percentages: Alignment rate changes over time
    CASE WHEN ws.prev_semester_alignment IS NOT NULL AND ws.prev_semester_alignment > 0 
         THEN ROUND(((ws.alignment_rate - ws.prev_semester_alignment) / ws.prev_semester_alignment * 100)::NUMERIC, 2)
         ELSE NULL END AS alignment_change_pct,
    CASE WHEN ws.prev_semester_joint_votes IS NOT NULL AND ws.prev_semester_joint_votes > 0 
         THEN ROUND(((ws.joint_votes - ws.prev_semester_joint_votes)::NUMERIC / ws.prev_semester_joint_votes * 100)::NUMERIC, 2)
         ELSE NULL END AS joint_votes_change_pct,
    
    -- Coalition strength classification
    CASE 
        WHEN ws.alignment_rate >= 75 THEN 'VERY_STRONG_COALITION'
        WHEN ws.alignment_rate >= 60 THEN 'STRONG_COALITION'
        WHEN ws.alignment_rate >= 45 THEN 'MODERATE_COALITION'
        WHEN ws.alignment_rate >= 30 THEN 'WEAK_COALITION'
        ELSE 'OPPOSITION'
    END AS coalition_strength,
    
    -- Trend direction with statistical significance
    CASE 
        WHEN ws.prev_semester_alignment IS NULL THEN 'BASELINE'
        WHEN ws.alignment_rate > ws.prev_semester_alignment + 15 THEN 'RAPIDLY_STRENGTHENING'
        WHEN ws.alignment_rate > ws.prev_semester_alignment + 10 THEN 'STRENGTHENING'
        WHEN ws.alignment_rate > ws.prev_semester_alignment + 5 THEN 'IMPROVING'
        WHEN ws.alignment_rate < ws.prev_semester_alignment - 15 THEN 'RAPIDLY_WEAKENING'
        WHEN ws.alignment_rate < ws.prev_semester_alignment - 10 THEN 'WEAKENING'
        WHEN ws.alignment_rate < ws.prev_semester_alignment - 5 THEN 'DECLINING'
        ELSE 'STABLE'
    END AS coalition_trend,
    
    -- Strategic shift detection (major realignments)
    CASE 
        WHEN ws.prev_semester_alignment IS NOT NULL 
             AND ws.prev_semester_alignment < 45 
             AND ws.alignment_rate >= 60 THEN 'COALITION_FORMATION'
        WHEN ws.prev_semester_alignment IS NOT NULL 
             AND ws.prev_semester_alignment >= 60 
             AND ws.alignment_rate < 45 THEN 'COALITION_BREAKUP'
        WHEN ws.prev_semester_alignment IS NOT NULL 
             AND ABS(ws.alignment_rate - ws.prev_semester_alignment) >= 20 THEN 'MAJOR_REALIGNMENT'
        WHEN ws.prev_semester_alignment IS NOT NULL 
             AND ABS(ws.alignment_rate - ws.prev_semester_alignment) >= 10 THEN 'SIGNIFICANT_SHIFT'
        ELSE 'NORMAL'
    END AS strategic_shift,
    
    -- Volatility classification
    CASE 
        WHEN ws.stddev_party_pair > 15 THEN 'HIGH_VOLATILITY_PAIR'
        WHEN ws.stddev_party_pair > 10 THEN 'MODERATE_VOLATILITY_PAIR'
        ELSE 'STABLE_PAIR'
    END AS volatility_classification,
    
    -- Forecast trend based on LEAD
    CASE 
        WHEN ws.next_semester_alignment IS NULL THEN 'NO_FORECAST'
        WHEN ws.next_semester_alignment > ws.alignment_rate + 10 THEN 'EXPECTED_STRENGTHENING'
        WHEN ws.next_semester_alignment < ws.alignment_rate - 10 THEN 'EXPECTED_WEAKENING'
        ELSE 'EXPECTED_STABLE'
    END AS forecast_trend,
    
    -- Coalition tier based on percentile rank
    CASE 
        WHEN ws.percent_rank_alignment >= 0.75 THEN 'TOP_COALITION'
        WHEN ws.percent_rank_alignment >= 0.50 THEN 'UPPER_MID_COALITION'
        WHEN ws.percent_rank_alignment >= 0.25 THEN 'LOWER_MID_COALITION'
        ELSE 'WEAK_COALITION'
    END AS coalition_tier,
    
    -- Momentum z-score (change relative to volatility)
    CASE 
        WHEN ws.prev_semester_alignment IS NOT NULL AND ws.stddev_party_pair > 0
        THEN ROUND(((ws.alignment_rate - ws.prev_semester_alignment) / NULLIF(ws.stddev_party_pair, 0))::NUMERIC, 2)
        ELSE NULL 
    END AS momentum_z_score
    
FROM windowed_statistics ws
ORDER BY ws.party_1, ws.party_2, ws.election_cycle_id, ws.cycle_year, ws.semester;
        ]]>
    </createView>
    
    <rollback>
        <dropView viewName="view_riksdagen_party_coalition_evolution"/>
    </rollback>
</changeSet>


<!-- ========================================================================= -->
<!-- 3. PARTY ELECTORAL TRENDS (ENHANCED WITH ADVANCED STATISTICS)            -->
<!-- ========================================================================= -->

<changeSet author="intelligence-operative" id="1.53-drop-electoral-trends" failOnError="false">
    <sql>DROP VIEW IF EXISTS view_riksdagen_party_electoral_trends CASCADE;</sql>
</changeSet>

<changeSet author="intelligence-operative" id="1.53-party-electoral-003" failOnError="true">
    <comment>
        Party Electoral Trends View (2002-2026) - ENHANCED
        
        Framework: Comparative Analysis, Predictive Intelligence
        
        ENHANCEMENTS:
        - Swedish parliament semester structure (autumn/spring)
        - RANK: Electoral performance ranking by cycle/semester
        - PERCENT_RANK: Percentile-based electoral comparison
        - NTILE: Size-based quartiles (major/large/medium/small parties)
        - LAG/LEAD: Previous/next semester seat counts for growth tracking
        - STDDEV_POP: Electoral volatility measurement
        - Change percentages: Seat count and win rate changes
        - Growth rate classification with momentum indicators
        
        Tracks electoral performance evolution: seat counts, win rates, 
        gender representation, and document productivity.
    </comment>
    
    <createView viewName="view_riksdagen_party_electoral_trends">
        <![CDATA[
WITH election_cycle_periods AS (
    SELECT 
        year_series AS calendar_year,
        CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2002
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2006
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2010
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2014
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2018
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2022
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2026
        END AS election_year,
        (year_series - CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2002
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2006
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2010
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2014
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2018
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2022
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2026
        END + 1) AS cycle_year,
        (CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2002
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2006
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2010
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2014
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2018
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2022
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2026
        END || '-' || (CASE 
            WHEN year_series BETWEEN 2002 AND 2005 THEN 2005
            WHEN year_series BETWEEN 2006 AND 2009 THEN 2009
            WHEN year_series BETWEEN 2010 AND 2013 THEN 2013
            WHEN year_series BETWEEN 2014 AND 2017 THEN 2017
            WHEN year_series BETWEEN 2018 AND 2021 THEN 2021
            WHEN year_series BETWEEN 2022 AND 2025 THEN 2025
            WHEN year_series BETWEEN 2026 AND 2029 THEN 2029
        END)) AS election_cycle_id,
        MAKE_DATE(year_series, 9, 1) AS autumn_start,
        MAKE_DATE(year_series + 1, 1, 25) AS autumn_end,
        MAKE_DATE(year_series, 1, 26) AS spring_start,
        MAKE_DATE(year_series, 8, 31) AS spring_end
    FROM generate_series(2002, EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER + 4, 1) AS year_series
    WHERE year_series >= 2002
),
electoral_autumn AS (
    SELECT 
        ecp.election_cycle_id,
        ecp.cycle_year,
        ecp.calendar_year,
        'autumn' AS semester,
        pd.party,
        COUNT(DISTINCT pd.id) AS seat_count,
        COUNT(DISTINCT pd.id) FILTER (WHERE pd.gender = 'KVINNA') AS female_seats,
        COUNT(DISTINCT vd.embedded_id_ballot_id) AS ballots_participated,
        ROUND((COUNT(CASE WHEN vd.vote = 'Ja' AND vd.won = TRUE THEN 1 END)::NUMERIC / 
               NULLIF(COUNT(DISTINCT vd.embedded_id_ballot_id), 0) * 100), 2) AS win_rate,
        COUNT(DISTINCT dd.id) AS documents_produced
    FROM election_cycle_periods ecp
    CROSS JOIN person_data pd
    LEFT JOIN vote_data vd ON vd.intressent_id = pd.id 
                           AND vd.vote_date BETWEEN ecp.autumn_start AND ecp.autumn_end
    LEFT JOIN document_data dd ON dd.person_reference_id = pd.id 
                               AND dd.made_public_date BETWEEN ecp.autumn_start AND ecp.autumn_end
    WHERE pd.party IS NOT NULL
      AND pd.status = 'Tjänstgörande riksdagsledamot'
      AND ecp.election_year IS NOT NULL
    GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, pd.party
),
electoral_spring AS (
    SELECT 
        ecp.election_cycle_id,
        ecp.cycle_year,
        ecp.calendar_year,
        'spring' AS semester,
        pd.party,
        COUNT(DISTINCT pd.id) AS seat_count,
        COUNT(DISTINCT pd.id) FILTER (WHERE pd.gender = 'KVINNA') AS female_seats,
        COUNT(DISTINCT vd.embedded_id_ballot_id) AS ballots_participated,
        ROUND((COUNT(CASE WHEN vd.vote = 'Ja' AND vd.won = TRUE THEN 1 END)::NUMERIC / 
               NULLIF(COUNT(DISTINCT vd.embedded_id_ballot_id), 0) * 100), 2) AS win_rate,
        COUNT(DISTINCT dd.id) AS documents_produced
    FROM election_cycle_periods ecp
    CROSS JOIN person_data pd
    LEFT JOIN vote_data vd ON vd.intressent_id = pd.id 
                           AND vd.vote_date BETWEEN ecp.spring_start AND ecp.spring_end
    LEFT JOIN document_data dd ON dd.person_reference_id = pd.id 
                               AND dd.made_public_date BETWEEN ecp.spring_start AND ecp.spring_end
    WHERE pd.party IS NOT NULL
      AND pd.status = 'Tjänstgörande riksdagsledamot'
      AND ecp.election_year IS NOT NULL
    GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, pd.party
),
base_electoral AS (
    SELECT * FROM electoral_autumn
    UNION ALL
    SELECT * FROM electoral_spring
),
windowed_statistics AS (
    SELECT 
        be.*,
        -- RANK: Electoral performance ranking
        RANK() OVER (PARTITION BY be.election_cycle_id, be.semester ORDER BY be.seat_count DESC NULLS LAST) AS rank_by_seats,
        RANK() OVER (PARTITION BY be.election_cycle_id, be.semester ORDER BY be.win_rate DESC NULLS LAST) AS rank_by_win_rate,
        
        -- PERCENT_RANK: Percentile-based electoral comparison
        PERCENT_RANK() OVER (PARTITION BY be.election_cycle_id, be.semester ORDER BY be.seat_count DESC NULLS LAST) AS percent_rank_seats,
        PERCENT_RANK() OVER (PARTITION BY be.election_cycle_id, be.semester ORDER BY be.documents_produced DESC NULLS LAST) AS percent_rank_documents,
        
        -- NTILE: Size-based quartiles
        NTILE(4) OVER (PARTITION BY be.election_cycle_id, be.semester ORDER BY be.seat_count DESC NULLS LAST) AS ntile_size,
        
        -- LAG: Previous semester metrics
        LAG(be.seat_count) OVER (PARTITION BY be.party ORDER BY be.election_cycle_id, be.cycle_year, be.semester) AS prev_semester_seats,
        LAG(be.win_rate) OVER (PARTITION BY be.party ORDER BY be.election_cycle_id, be.cycle_year, be.semester) AS prev_semester_win_rate,
        LAG(be.female_seats) OVER (PARTITION BY be.party ORDER BY be.election_cycle_id, be.cycle_year, be.semester) AS prev_semester_female_seats,
        
        -- LEAD: Next semester metrics
        LEAD(be.seat_count) OVER (PARTITION BY be.party ORDER BY be.election_cycle_id, be.cycle_year, be.semester) AS next_semester_seats,
        LEAD(be.win_rate) OVER (PARTITION BY be.party ORDER BY be.election_cycle_id, be.cycle_year, be.semester) AS next_semester_win_rate,
        
        -- STDDEV_POP: Electoral volatility
        STDDEV_POP(be.seat_count) OVER (PARTITION BY be.election_cycle_id, be.semester) AS stddev_seats,
        STDDEV_POP(be.win_rate) OVER (PARTITION BY be.election_cycle_id, be.semester) AS stddev_win_rate,
        STDDEV_POP(be.seat_count) OVER (PARTITION BY be.party) AS stddev_party_seats
    FROM base_electoral be
)
SELECT 
    ws.*,
    -- Gender representation percentage
    ROUND((ws.female_seats::NUMERIC / NULLIF(ws.seat_count, 0) * 100), 2) AS female_representation_pct,
    
    -- Change percentages
    CASE WHEN ws.prev_semester_seats IS NOT NULL AND ws.prev_semester_seats > 0 
         THEN ROUND(((ws.seat_count - ws.prev_semester_seats)::NUMERIC / ws.prev_semester_seats * 100)::NUMERIC, 2)
         ELSE NULL END AS seat_change_pct,
    CASE WHEN ws.prev_semester_win_rate IS NOT NULL AND ws.prev_semester_win_rate > 0 
         THEN ROUND(((ws.win_rate - ws.prev_semester_win_rate) / ws.prev_semester_win_rate * 100)::NUMERIC, 2)
         ELSE NULL END AS win_rate_change_pct,
    
    -- Absolute changes
    CASE WHEN ws.prev_semester_seats IS NOT NULL THEN (ws.seat_count - ws.prev_semester_seats) ELSE NULL END AS seat_change,
    CASE WHEN ws.prev_semester_win_rate IS NOT NULL THEN ROUND(ws.win_rate - ws.prev_semester_win_rate, 2) ELSE NULL END AS win_rate_change,
    
    -- Electoral trend classification
    CASE 
        WHEN ws.prev_semester_seats IS NULL THEN 'BASELINE'
        WHEN ws.seat_count > ws.prev_semester_seats + 10 THEN 'SURGING'
        WHEN ws.seat_count > ws.prev_semester_seats + 5 THEN 'STRONG_GROWTH'
        WHEN ws.seat_count > ws.prev_semester_seats THEN 'GROWTH'
        WHEN ws.seat_count < ws.prev_semester_seats - 10 THEN 'COLLAPSING'
        WHEN ws.seat_count < ws.prev_semester_seats - 5 THEN 'STRONG_DECLINE'
        WHEN ws.seat_count < ws.prev_semester_seats THEN 'DECLINE'
        ELSE 'STABLE'
    END AS electoral_trend,
    
    -- Party size category
    CASE 
        WHEN ws.seat_count >= 100 THEN 'DOMINANT_PARTY'
        WHEN ws.seat_count >= 75 THEN 'MAJOR_PARTY'
        WHEN ws.seat_count >= 50 THEN 'LARGE_PARTY'
        WHEN ws.seat_count >= 25 THEN 'MEDIUM_PARTY'
        WHEN ws.seat_count >= 10 THEN 'SMALL_PARTY'
        ELSE 'MINOR_PARTY'
    END AS party_size_category,
    
    -- Volatility classification
    CASE 
        WHEN ws.stddev_party_seats > 15 THEN 'HIGHLY_VOLATILE'
        WHEN ws.stddev_party_seats > 10 THEN 'MODERATELY_VOLATILE'
        ELSE 'STABLE_PARTY'
    END AS volatility_classification,
    
    -- Forecast trend based on LEAD
    CASE 
        WHEN ws.next_semester_seats IS NULL THEN 'NO_FORECAST'
        WHEN ws.next_semester_seats > ws.seat_count + 5 THEN 'EXPECTED_GROWTH'
        WHEN ws.next_semester_seats < ws.seat_count - 5 THEN 'EXPECTED_DECLINE'
        ELSE 'EXPECTED_STABLE'
    END AS forecast_trend,
    
    -- Electoral tier based on percentile rank
    CASE 
        WHEN ws.percent_rank_seats >= 0.75 THEN 'TOP_ELECTORAL_TIER'
        WHEN ws.percent_rank_seats >= 0.50 THEN 'UPPER_MID_TIER'
        WHEN ws.percent_rank_seats >= 0.25 THEN 'LOWER_MID_TIER'
        ELSE 'BOTTOM_TIER'
    END AS electoral_tier,
    
    -- Momentum z-score (growth rate relative to volatility)
    CASE 
        WHEN ws.prev_semester_seats IS NOT NULL AND ws.stddev_party_seats > 0
        THEN ROUND(((ws.seat_count - ws.prev_semester_seats)::NUMERIC / NULLIF(ws.stddev_party_seats, 0))::NUMERIC, 2)
        ELSE NULL 
    END AS momentum_z_score,
    
    -- Composite electoral strength score
    ROUND(((ws.seat_count::NUMERIC / NULLIF((MAX(ws.seat_count) OVER (PARTITION BY ws.election_cycle_id, ws.semester)), 0) * 50) +
           (ws.win_rate * 0.3) +
           (ws.documents_produced::NUMERIC / NULLIF((MAX(ws.documents_produced) OVER (PARTITION BY ws.election_cycle_id, ws.semester)), 0) * 20))::NUMERIC, 2) AS composite_electoral_score
    
FROM windowed_statistics ws
ORDER BY ws.party, ws.election_cycle_id, ws.cycle_year, ws.semester;
        ]]>
    </createView>
    
    <rollback>
        <dropView viewName="view_riksdagen_party_electoral_trends"/>
    </rollback>
</changeSet>


<!-- ========================================================================= -->
<!-- VALIDATION: Verify Enhanced Views Created Successfully                  -->
<!-- ========================================================================= -->

<changeSet id="1.53-validation" author="intelligence-operative">
    <comment>
        Validate that all 3 enhanced party longitudinal views were created successfully
        with advanced statistical functions and Swedish parliament semester structure.
    </comment>
    
    <sql splitStatements="false"><![CDATA[
        DO $$
        DECLARE
            v_performance_exists BOOLEAN;
            v_coalition_exists BOOLEAN;
            v_electoral_exists BOOLEAN;
        BEGIN
            SELECT EXISTS(
                SELECT 1 FROM information_schema.views 
                WHERE table_name = 'view_riksdagen_party_longitudinal_performance'
            ) INTO v_performance_exists;
            
            SELECT EXISTS(
                SELECT 1 FROM information_schema.views 
                WHERE table_name = 'view_riksdagen_party_coalition_evolution'
            ) INTO v_coalition_exists;
            
            SELECT EXISTS(
                SELECT 1 FROM information_schema.views 
                WHERE table_name = 'view_riksdagen_party_electoral_trends'
            ) INTO v_electoral_exists;
            
            IF v_performance_exists AND v_coalition_exists AND v_electoral_exists THEN
                RAISE NOTICE '✓ All 3 ENHANCED party longitudinal views created successfully';
                RAISE NOTICE '  ENHANCEMENTS APPLIED:';
                RAISE NOTICE '  - Advanced statistics: RANK, PERCENT_RANK, NTILE, LAG, LEAD, STDDEV_POP';
                RAISE NOTICE '  - Swedish parliament cycles: autumn (Sep-Jan) & spring (Jan-Aug) semesters';
                RAISE NOTICE '  - Multi-dimensional trend detection with volatility assessment';
                RAISE NOTICE '  - Predictive indicators and forecast trends';
                RAISE NOTICE '  - Enhanced comparative analysis with percentile rankings';
                RAISE NOTICE '  Coverage: 2002-2026 (7 election cycles, autumn/spring semesters)';
            ELSE
                RAISE WARNING 'Some enhanced party longitudinal views failed to create';
                IF NOT v_performance_exists THEN
                    RAISE WARNING '  - view_riksdagen_party_longitudinal_performance missing';
                END IF;
                IF NOT v_coalition_exists THEN
                    RAISE WARNING '  - view_riksdagen_party_coalition_evolution missing';
                END IF;
                IF NOT v_electoral_exists THEN
                    RAISE WARNING '  - view_riksdagen_party_electoral_trends missing';
                END IF;
            END IF;
        END $$;
    ]]></sql>
</changeSet>

</databaseChangeLog>
