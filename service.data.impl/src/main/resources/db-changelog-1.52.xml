<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.6.xsd">

<changeSet id="1.52-intro" author="intelligence-operative-analytics">
    <comment>v1.52 Statistical Enhancements</comment>
    <sql>SELECT 'v1.52' AS version, CURRENT_TIMESTAMP AS applied_at;</sql>
</changeSet>

<!-- VIEW 1: TEMPORAL TRENDS -->
<changeSet id="1.52-drop-temporal" author="intelligence-operative-analytics" failOnError="false">
    <sql>DROP VIEW IF EXISTS view_election_cycle_temporal_trends CASCADE;</sql>
</changeSet>

<changeSet id="1.52-temporal" author="intelligence-operative-analytics" failOnError="true">
    <createView viewName="view_election_cycle_temporal_trends">
        <![CDATA[
WITH v151_base AS (
WITH election_cycle_calendar AS (
    SELECT 
        year_series AS calendar_year,
        (1994 + (FLOOR((year_series - 1994) / 4.0) * 4))::INTEGER AS cycle_start_year,
        (1994 + (FLOOR((year_series - 1994) / 4.0) * 4) + 4)::INTEGER AS cycle_end_year
    FROM generate_series(1994, EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER + 4, 1) AS year_series
),
election_cycle_periods AS (
    SELECT 
        calendar_year,
        cycle_start_year,
        cycle_end_year,
        (cycle_start_year || '-' || cycle_end_year) AS election_cycle_id,
        (calendar_year - cycle_start_year + 1) AS cycle_year,
        MAKE_DATE(calendar_year, 9, 1) AS autumn_start,
        MAKE_DATE(calendar_year + 1, 1, 25) AS autumn_end,
        MAKE_DATE(calendar_year, 1, 26) AS spring_start,
        MAKE_DATE(calendar_year, 8, 31) AS spring_end,
        CASE WHEN (calendar_year - cycle_start_year + 1) = 4 THEN TRUE ELSE FALSE END AS is_election_year
    FROM election_cycle_calendar
),
temporal_data_autumn AS (
    SELECT 
        ecp.election_cycle_id,
        ecp.cycle_year,
        ecp.calendar_year,
        'autumn' AS semester,
        FALSE AS is_pre_election_semester,
        EXTRACT(YEAR FROM AGE(MAKE_DATE(ecp.cycle_end_year, 9, 15), ecp.autumn_start))::INTEGER * 12 + 
        EXTRACT(MONTH FROM AGE(MAKE_DATE(ecp.cycle_end_year, 9, 15), ecp.autumn_start))::INTEGER AS months_until_election,
        
        -- From view_politician_behavioral_trends
        COUNT(DISTINCT pbt.person_id) AS active_politicians,
        ROUND(AVG(100 - pbt.avg_absence_rate), 2) AS avg_attendance_rate,
        SUM(pbt.total_ballots) AS total_ballots,
        SUM(pbt.total_votes) AS total_votes,
        ROUND(AVG(pbt.avg_win_rate), 2) AS avg_win_rate,
        ROUND(AVG(pbt.avg_rebel_rate), 2) AS avg_rebel_rate,
        SUM(pbt.violation_count) AS violation_count,
        ROUND(AVG(pbt.ma_3month_absence), 2) AS avg_ma_absence,
        
        -- From view_decision_temporal_trends (NEW)
        ROUND(AVG(dtt.daily_approval_rate), 2) AS avg_approval_rate,
        SUM(dtt.daily_decisions) AS total_decisions,
        
        -- From view_committee_productivity (NEW)
        ROUND(AVG(cp.productivity_score), 2) AS avg_committee_productivity
        
    FROM election_cycle_periods ecp
    LEFT JOIN view_politician_behavioral_trends pbt
        ON pbt.period_start >= ecp.autumn_start AND pbt.period_start <= ecp.autumn_end
    LEFT JOIN view_decision_temporal_trends dtt
        ON dtt.decision_day >= ecp.autumn_start AND dtt.decision_day <= ecp.autumn_end
    LEFT JOIN view_committee_productivity cp
        ON 1=1  -- Current snapshot, no temporal filtering available
    GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, ecp.autumn_start, ecp.cycle_end_year
),
temporal_data_spring AS (
    SELECT 
        ecp.election_cycle_id,
        ecp.cycle_year,
        ecp.calendar_year,
        'spring' AS semester,
        CASE WHEN ecp.is_election_year THEN TRUE ELSE FALSE END AS is_pre_election_semester,
        EXTRACT(YEAR FROM AGE(MAKE_DATE(ecp.cycle_end_year, 9, 15), ecp.spring_start))::INTEGER * 12 + 
        EXTRACT(MONTH FROM AGE(MAKE_DATE(ecp.cycle_end_year, 9, 15), ecp.spring_start))::INTEGER AS months_until_election,
        
        COUNT(DISTINCT pbt.person_id) AS active_politicians,
        ROUND(AVG(100 - pbt.avg_absence_rate), 2) AS avg_attendance_rate,
        SUM(pbt.total_ballots) AS total_ballots,
        SUM(pbt.total_votes) AS total_votes,
        ROUND(AVG(pbt.avg_win_rate), 2) AS avg_win_rate,
        ROUND(AVG(pbt.avg_rebel_rate), 2) AS avg_rebel_rate,
        SUM(pbt.violation_count) AS violation_count,
        ROUND(AVG(pbt.ma_3month_absence), 2) AS avg_ma_absence,
        ROUND(AVG(dtt.daily_approval_rate), 2) AS avg_approval_rate,
        SUM(dtt.daily_decisions) AS total_decisions,
        ROUND(AVG(cp.productivity_score), 2) AS avg_committee_productivity
        
    FROM election_cycle_periods ecp
    LEFT JOIN view_politician_behavioral_trends pbt
        ON pbt.period_start >= ecp.spring_start AND pbt.period_start <= ecp.spring_end
    LEFT JOIN view_decision_temporal_trends dtt
        ON dtt.decision_day >= ecp.spring_start AND dtt.decision_day <= ecp.spring_end
    LEFT JOIN view_committee_productivity cp
        ON 1=1  -- Current snapshot, no temporal filtering available
    GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, ecp.spring_start, ecp.cycle_end_year, ecp.is_election_year
)
SELECT * FROM temporal_data_autumn
UNION ALL
SELECT * FROM temporal_data_spring
ORDER BY election_cycle_id, cycle_year, semester
),
windowed AS (
    SELECT v.*,
        RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_attendance_rate DESC NULLS LAST) AS rank_by_attendance,
        PERCENT_RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_attendance_rate DESC NULLS LAST) AS percent_rank_attendance,
        NTILE(4) OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_attendance_rate DESC NULLS LAST) AS ntile_performance,
        LAG(v.avg_attendance_rate) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS prev_semester_attendance,
        LAG(v.total_decisions) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS prev_semester_decisions,
        LEAD(v.avg_attendance_rate) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS next_semester_attendance,
        STDDEV_POP(v.avg_attendance_rate) OVER (PARTITION BY v.election_cycle_id) AS stddev_attendance,
        STDDEV_POP(v.avg_win_rate) OVER (PARTITION BY v.election_cycle_id) AS stddev_win_rate,
        STDDEV_POP(v.total_decisions) OVER (PARTITION BY v.election_cycle_id) AS stddev_decisions
    FROM v151_base v
)
SELECT w.*,
    CASE WHEN w.prev_semester_attendance IS NOT NULL AND w.prev_semester_attendance > 0 
         THEN ROUND(((w.avg_attendance_rate - w.prev_semester_attendance) / w.prev_semester_attendance * 100)::NUMERIC, 2)
         ELSE NULL END AS change_attendance_pct,
    CASE WHEN w.prev_semester_decisions IS NOT NULL AND w.prev_semester_decisions > 0 
         THEN ROUND(((w.total_decisions - w.prev_semester_decisions)::NUMERIC / w.prev_semester_decisions * 100)::NUMERIC, 2)
         ELSE NULL END AS change_decisions_pct,
    CASE WHEN w.prev_semester_attendance IS NULL THEN 'baseline'
         WHEN w.avg_attendance_rate > w.prev_semester_attendance + 5 THEN 'improving'
         WHEN w.avg_attendance_rate < w.prev_semester_attendance - 5 THEN 'declining'
         ELSE 'stable' END AS attendance_trend,
    CASE WHEN w.avg_attendance_rate IS NOT NULL AND w.avg_win_rate IS NOT NULL
         THEN ROUND((w.avg_attendance_rate * 0.5 + w.avg_win_rate * 0.5)::NUMERIC, 2)
         ELSE NULL END AS overall_performance_score,
    CASE WHEN w.stddev_attendance > 10 THEN 'high_volatility'
         WHEN w.stddev_attendance > 5 THEN 'moderate_volatility'
         ELSE 'stable' END AS volatility_assessment,
    CASE WHEN w.next_semester_attendance IS NOT NULL AND w.next_semester_attendance > w.avg_attendance_rate + 5 THEN 'expected_improvement'
         WHEN w.next_semester_attendance IS NOT NULL AND w.next_semester_attendance < w.avg_attendance_rate - 5 THEN 'expected_decline'
         ELSE 'stable_forecast' END AS forecast_trend
FROM windowed w;
        ]]>
    </createView>
</changeSet>

<!-- VIEW 2: COMPARATIVE ANALYSIS -->
<changeSet id="1.52-drop-comparative" author="intelligence-operative-analytics" failOnError="false">
    <sql>DROP VIEW IF EXISTS view_election_cycle_comparative_analysis CASCADE;</sql>
</changeSet>

<changeSet id="1.52-comparative" author="intelligence-operative-analytics" failOnError="true">
    <createView viewName="view_election_cycle_comparative_analysis">
        <![CDATA[
WITH v151_base AS (
WITH election_cycle_periods AS (
    SELECT 
        (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) || '-' || (1994 + (FLOOR((year_series - 1994) / 4.0) * 4) + 4) AS election_cycle_id,
        (year_series - (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) + 1) AS cycle_year,
        year_series AS calendar_year
    FROM generate_series(1994, EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER + 4, 1) AS year_series
)
SELECT 
    ecp.election_cycle_id,
    ecp.cycle_year,
    ecp.calendar_year,
    'annual' AS semester,  -- Simplified: aggregate by year since source views are current snapshots
    ppm.party,
    
    -- From view_party_performance_metrics (NEW - provides comprehensive party analytics)
    MAX(ppm.performance_score) AS performance_score,
    MAX(ppm.active_members) AS active_members,
    MAX(ppm.total_violations) AS party_violations,
    ROUND(AVG(ppm.avg_win_rate), 2) AS party_win_rate,
    ROUND(AVG(ppm.avg_participation_rate), 2) AS party_participation_rate,
    MAX(ppm.documents_last_year) AS documents_last_year,
    ROUND(AVG(ppm.avg_rebel_rate), 2) AS party_avg_rebel_rate,
    
    -- From view_committee_productivity_matrix (NEW - multi-committee dimension)
    COUNT(DISTINCT cpm.committee_code) AS committees_active
    
FROM election_cycle_periods ecp
CROSS JOIN view_party_performance_metrics ppm
LEFT JOIN view_committee_productivity_matrix cpm
    ON EXTRACT(YEAR FROM cpm.period_start) = ecp.calendar_year
WHERE ppm.party IS NOT NULL
GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, ppm.party
ORDER BY election_cycle_id, cycle_year, semester, party
),
windowed AS (
    SELECT v.*,
        RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.performance_score DESC NULLS LAST) AS rank_by_performance,
        RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.party_avg_rebel_rate ASC NULLS LAST) AS rank_by_discipline,
        PERCENT_RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.performance_score DESC NULLS LAST) AS percent_rank_performance,
        NTILE(4) OVER (PARTITION BY v.election_cycle_id ORDER BY v.performance_score DESC NULLS LAST) AS ntile_party_tier,
        LAG(v.performance_score) OVER (PARTITION BY v.election_cycle_id, v.party ORDER BY v.cycle_year) AS prev_cycle_performance,
        LAG(v.documents_last_year) OVER (PARTITION BY v.election_cycle_id, v.party ORDER BY v.cycle_year) AS prev_cycle_documents,
        STDDEV_POP(v.performance_score) OVER (PARTITION BY v.election_cycle_id) AS stddev_performance,
        COUNT(*) OVER (PARTITION BY v.election_cycle_id) AS cycle_party_count
    FROM v151_base v
)
SELECT w.*,
    CASE WHEN w.prev_cycle_performance IS NOT NULL AND w.prev_cycle_performance > 0 
         THEN ROUND(((w.performance_score - w.prev_cycle_performance) / w.prev_cycle_performance * 100)::NUMERIC, 2)
         ELSE NULL END AS change_performance_pct,
    CASE WHEN w.prev_cycle_documents IS NOT NULL AND w.prev_cycle_documents > 0 
         THEN ROUND(((w.documents_last_year - w.prev_cycle_documents)::NUMERIC / w.prev_cycle_documents * 100)::NUMERIC, 2)
         ELSE NULL END AS change_documents_pct,
    CASE WHEN w.prev_cycle_performance IS NULL THEN 'baseline'
         WHEN w.performance_score > w.prev_cycle_performance + 10 THEN 'improving'
         WHEN w.performance_score < w.prev_cycle_performance - 10 THEN 'declining'
         ELSE 'stable' END AS performance_trend,
    ROUND((w.performance_score * 0.4 + w.party_win_rate * 0.3 + w.party_participation_rate * 0.3)::NUMERIC, 2) AS discipline_score,
    ROUND((w.rank_by_performance::NUMERIC / NULLIF(w.cycle_party_count, 0)) * 100, 2) AS competitiveness_index
FROM windowed w;
        ]]>
    </createView>
</changeSet>

<!-- VIEW 3: ANOMALY PATTERN -->
<changeSet id="1.52-drop-anomaly" author="intelligence-operative-analytics" failOnError="false">
    <sql>DROP VIEW IF EXISTS view_election_cycle_anomaly_pattern CASCADE;</sql>
</changeSet>

<changeSet id="1.52-anomaly" author="intelligence-operative-analytics" failOnError="true">
    <createView viewName="view_election_cycle_anomaly_pattern">
        <![CDATA[
WITH v151_base AS (
WITH election_cycle_periods AS (
    SELECT 
        (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) || '-' || (1994 + (FLOOR((year_series - 1994) / 4.0) * 4) + 4) AS election_cycle_id,
        (year_series - (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) + 1) AS cycle_year,
        year_series AS calendar_year
    FROM generate_series(1994, EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER + 4, 1) AS year_series
)
SELECT 
    ecp.election_cycle_id,
    ecp.cycle_year,
    ecp.calendar_year,
    CASE WHEN EXTRACT(MONTH FROM rse.assessment_period) >= 9 OR EXTRACT(MONTH FROM rse.assessment_period) <= 1 THEN 'autumn' ELSE 'spring' END AS semester,
    
    -- Anomaly classification
    'MULTI_SOURCE_PATTERN' AS anomaly_type,
    
    -- From view_risk_score_evolution
    COUNT(DISTINCT rse.person_id) FILTER (WHERE rse.risk_severity IN ('HIGH', 'CRITICAL')) AS politician_count_with_risk,
    ROUND(AVG(rse.risk_score), 2) AS avg_risk_score,
    COUNT(*) FILTER (WHERE rse.severity_transition LIKE 'ESCALATION%') AS risk_escalations,
    
    -- From view_riksdagen_voting_anomaly_detection (NEW - uses actual columns: total_rebellions, anomaly_classification)
    COUNT(DISTINCT vad.person_id) FILTER (WHERE vad.anomaly_classification IN ('FREQUENT_STRONG_REBEL', 'CONSISTENT_REBEL')) AS high_anomaly_count,
    ROUND(AVG(vad.total_rebellions), 2) AS avg_total_rebellions,
    COUNT(DISTINCT vad.person_id) FILTER (WHERE vad.strong_consensus_rebellions >= 5) AS strong_consensus_rebels,
    
    -- From view_politician_risk_summary (NEW - aggregated risk profiles)
    ROUND(AVG(prs.risk_score), 2) AS avg_risk_score_prs,
    COUNT(DISTINCT prs.person_id) FILTER (WHERE prs.risk_level IN ('HIGH', 'CRITICAL')) AS high_risk_politicians
    
FROM election_cycle_periods ecp
LEFT JOIN view_risk_score_evolution rse
    ON EXTRACT(YEAR FROM rse.assessment_period) = ecp.calendar_year
LEFT JOIN view_riksdagen_voting_anomaly_detection vad
    ON 1=1  -- Current snapshot (3-year rolling window), no temporal filtering available
LEFT JOIN view_politician_risk_summary prs
    ON 1=1  -- Current snapshot, not time-filtered
GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, 
    CASE WHEN EXTRACT(MONTH FROM rse.assessment_period) >= 9 OR EXTRACT(MONTH FROM rse.assessment_period) <= 1 THEN 'autumn' ELSE 'spring' END
ORDER BY election_cycle_id, cycle_year, semester
),
windowed AS (
    SELECT v.*,
        RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_risk_score DESC NULLS LAST) AS rank_by_risk,
        RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.high_anomaly_count DESC NULLS LAST) AS rank_by_anomalies,
        PERCENT_RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_risk_score DESC NULLS LAST) AS percent_rank_risk,
        NTILE(4) OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_risk_score DESC NULLS LAST) AS ntile_risk_level,
        LAG(v.avg_risk_score) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS prev_semester_risk,
        LAG(v.high_anomaly_count) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS prev_semester_anomalies
    FROM v151_base v
)
SELECT w.*,
    CASE WHEN w.prev_semester_risk IS NOT NULL AND w.prev_semester_risk > 0 
         THEN ROUND(((w.avg_risk_score - w.prev_semester_risk) / w.prev_semester_risk * 100)::NUMERIC, 2)
         ELSE NULL END AS change_risk_pct,
    CASE WHEN w.prev_semester_anomalies IS NOT NULL AND w.prev_semester_anomalies > 0 
         THEN ROUND(((w.high_anomaly_count - w.prev_semester_anomalies)::NUMERIC / w.prev_semester_anomalies * 100)::NUMERIC, 2)
         ELSE NULL END AS change_anomalies_pct,
    CASE WHEN w.prev_semester_risk IS NULL THEN 'baseline'
         WHEN w.avg_risk_score > w.prev_semester_risk + 10 THEN 'escalating'
         WHEN w.avg_risk_score < w.prev_semester_risk - 10 THEN 'improving'
         ELSE 'stable' END AS risk_trend,
    CASE WHEN w.prev_semester_anomalies IS NOT NULL 
         THEN w.high_anomaly_count - w.prev_semester_anomalies ELSE 0 END AS anomaly_acceleration
FROM windowed w;
        ]]>
    </createView>
</changeSet>

<!-- VIEW 4: PREDICTIVE INTELLIGENCE -->
<changeSet id="1.52-drop-predictive" author="intelligence-operative-analytics" failOnError="false">
    <sql>DROP VIEW IF EXISTS view_election_cycle_predictive_intelligence CASCADE;</sql>
</changeSet>

<changeSet id="1.52-predictive" author="intelligence-operative-analytics" failOnError="true">
    <createView viewName="view_election_cycle_predictive_intelligence">
        <![CDATA[
WITH v151_base AS (
WITH election_cycle_periods AS (
    SELECT 
        (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) || '-' || (1994 + (FLOOR((year_series - 1994) / 4.0) * 4) + 4) AS election_cycle_id,
        (year_series - (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) + 1) AS cycle_year,
        year_series AS calendar_year
    FROM generate_series(1994, EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER + 4, 1) AS year_series
)
SELECT 
    ecp.election_cycle_id,
    ecp.cycle_year,
    ecp.calendar_year,
    CASE WHEN EXTRACT(MONTH FROM rse.assessment_period) >= 9 OR EXTRACT(MONTH FROM rse.assessment_period) <= 1 THEN 'autumn' ELSE 'spring' END AS semester,
    
    -- From view_risk_score_evolution (risk forecasting)
    CASE 
        WHEN AVG(rse.risk_score_change) >= 10 THEN 'RAPID_ESCALATION'
        WHEN AVG(rse.risk_score_change) >= 5 THEN 'MODERATE_ESCALATION'
        WHEN AVG(rse.risk_score_change) <= -5 THEN 'IMPROVING'
        ELSE 'STABLE'
    END AS risk_forecast_category,
    COUNT(DISTINCT rse.person_id) FILTER (WHERE rse.risk_trend LIKE '%INCREASE%') AS politicians_at_risk,
    ROUND(AVG(rse.risk_score_change), 2) AS avg_risk_score_change,
    
    -- From view_ministry_risk_evolution (NEW - government stability forecasting)
    COUNT(DISTINCT mre.name) FILTER (WHERE mre.risk_level IN ('HIGH', 'CRITICAL')) AS ministries_at_risk,
    ROUND(AVG(mre.rolling_avg_documents), 2) AS avg_ministry_productivity,
    
    -- From view_party_effectiveness_trends (NEW - party performance forecasting)
    ROUND(AVG(pet.win_rate_trend), 2) AS avg_party_win_rate_trend,
    COUNT(DISTINCT pet.party) FILTER (WHERE pet.absence_trend > 0) AS parties_with_increasing_absence
    
FROM election_cycle_periods ecp
LEFT JOIN view_risk_score_evolution rse
    ON EXTRACT(YEAR FROM rse.assessment_period) = ecp.calendar_year
LEFT JOIN view_ministry_risk_evolution mre
    ON EXTRACT(YEAR FROM mre.assessment_period) = ecp.calendar_year
LEFT JOIN view_party_effectiveness_trends pet
    ON EXTRACT(YEAR FROM pet.period_start) = ecp.calendar_year
GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, 
    CASE WHEN EXTRACT(MONTH FROM rse.assessment_period) >= 9 OR EXTRACT(MONTH FROM rse.assessment_period) <= 1 THEN 'autumn' ELSE 'spring' END
ORDER BY election_cycle_id, cycle_year, semester
),
windowed AS (
    SELECT v.*,
        RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_risk_score_change DESC NULLS LAST) AS rank_by_risk_score,
        PERCENT_RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_risk_score_change DESC NULLS LAST) AS percent_rank_risk,
        NTILE(4) OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_risk_score_change DESC NULLS LAST) AS ntile_forecast_group,
        LAG(v.avg_risk_score_change) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS prev_semester_risk,
        LEAD(v.avg_risk_score_change) OVER (PARTITION BY v.election_cycle_id ORDER BY v.cycle_year, v.semester) AS lead_semester_risk,
        STDDEV_POP(v.avg_risk_score_change) OVER (PARTITION BY v.election_cycle_id) AS stddev_risk
    FROM v151_base v
)
SELECT w.*,
    CASE WHEN w.prev_semester_risk IS NOT NULL AND w.prev_semester_risk > 0 
         THEN ROUND(((w.avg_risk_score_change - w.prev_semester_risk) / w.prev_semester_risk * 100)::NUMERIC, 2)
         ELSE NULL END AS change_risk_pct,
    CASE WHEN w.prev_semester_risk IS NULL THEN 'baseline'
         WHEN w.avg_risk_score_change > w.prev_semester_risk + 10 THEN 'increasing'
         WHEN w.avg_risk_score_change < w.prev_semester_risk - 10 THEN 'decreasing'
         ELSE 'stable' END AS risk_trajectory,
    CASE WHEN w.stddev_risk < 5 THEN 'high_confidence'
         WHEN w.stddev_risk < 10 THEN 'moderate_confidence'
         ELSE 'low_confidence' END AS forecast_confidence,
    CASE WHEN w.avg_risk_score_change > 75 THEN 'high'
         WHEN w.avg_risk_score_change > 50 THEN 'medium'
         ELSE 'low' END AS predictive_alert_level
FROM windowed w;
        ]]>
    </createView>
</changeSet>

<!-- VIEW 5: NETWORK ANALYSIS -->
<changeSet id="1.52-drop-network" author="intelligence-operative-analytics" failOnError="false">
    <sql>DROP VIEW IF EXISTS view_election_cycle_network_analysis CASCADE;</sql>
</changeSet>

<changeSet id="1.52-network" author="intelligence-operative-analytics" failOnError="true">
    <createView viewName="view_election_cycle_network_analysis">
        <![CDATA[
WITH v151_base AS (
WITH election_cycle_periods AS (
    SELECT 
        (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) || '-' || (1994 + (FLOOR((year_series - 1994) / 4.0) * 4) + 4) AS election_cycle_id,
        (year_series - (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) + 1) AS cycle_year,
        year_series AS calendar_year
    FROM generate_series(2020, EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER + 4, 1) AS year_series
)
SELECT 
    ecp.election_cycle_id,
    ecp.cycle_year,
    ecp.calendar_year,
    'aggregate' AS semester,
    
    -- From view_riksdagen_coalition_alignment_matrix
    cam.party1,
    cam.party2,
    cam.alignment_rate,
    CASE 
        WHEN cam.alignment_rate >= 80 THEN 'STRONG_COALITION'
        WHEN cam.alignment_rate >= 60 THEN 'MODERATE_COALITION'
        ELSE 'WEAK_COALITION'
    END AS coalition_strength,
    
    -- From view_riksdagen_politician_influence_metrics (NEW - network analysis)
    COUNT(DISTINCT pim.person_id) FILTER (WHERE pim.influence_classification IN ('HIGH_INFLUENCE', 'VERY_HIGH_INFLUENCE')) AS influential_politicians,
    ROUND(AVG(pim.network_median), 2) AS avg_network_centrality,
    COUNT(DISTINCT pim.person_id) FILTER (WHERE pim.broker_classification = 'POWER_BROKER') AS power_broker_count
    
FROM election_cycle_periods ecp
CROSS JOIN view_riksdagen_coalition_alignment_matrix cam
LEFT JOIN view_riksdagen_politician_influence_metrics pim
    ON 1=1  -- Current snapshot
WHERE cam.party1 IS NOT NULL AND cam.party2 IS NOT NULL
GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, cam.party1, cam.party2, cam.alignment_rate
ORDER BY election_cycle_id, cycle_year, alignment_rate DESC
),
windowed AS (
    SELECT v.*,
        RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.alignment_rate DESC NULLS LAST) AS rank_by_alignment,
        PERCENT_RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.alignment_rate DESC NULLS LAST) AS percent_rank_alignment,
        NTILE(4) OVER (PARTITION BY v.election_cycle_id ORDER BY v.alignment_rate DESC NULLS LAST) AS ntile_coalition_strength,
        LAG(v.alignment_rate) OVER (PARTITION BY v.election_cycle_id, v.party1, v.party2 ORDER BY v.cycle_year, v.semester) AS prev_semester_alignment,
        STDDEV_POP(v.alignment_rate) OVER (PARTITION BY v.election_cycle_id) AS stddev_alignment
    FROM v151_base v
)
SELECT w.*,
    CASE WHEN w.prev_semester_alignment IS NOT NULL AND w.prev_semester_alignment > 0 
         THEN ROUND(((w.alignment_rate - w.prev_semester_alignment) / w.prev_semester_alignment * 100)::NUMERIC, 2)
         ELSE NULL END AS change_alignment_pct,
    CASE WHEN w.prev_semester_alignment IS NULL THEN 'baseline'
         WHEN w.alignment_rate > w.prev_semester_alignment + 10 THEN 'strengthening'
         WHEN w.alignment_rate < w.prev_semester_alignment - 10 THEN 'weakening'
         ELSE 'stable' END AS coalition_stability_trend,
    ROUND((w.alignment_rate / 100.0) * (100.0 / NULLIF(w.stddev_alignment, 0)), 2) AS network_density,
    CASE WHEN w.alignment_rate > 70 THEN 'strong'
         WHEN w.alignment_rate > 40 THEN 'moderate'
         ELSE 'weak' END AS coalition_momentum
FROM windowed w;
        ]]>
    </createView>
</changeSet>

<!-- VIEW 6: DECISION INTELLIGENCE -->
<changeSet id="1.52-drop-decision" author="intelligence-operative-analytics" failOnError="false">
    <sql>DROP VIEW IF EXISTS view_election_cycle_decision_intelligence CASCADE;</sql>
</changeSet>

<changeSet id="1.52-decision" author="intelligence-operative-analytics" failOnError="true">
    <createView viewName="view_election_cycle_decision_intelligence">
        <![CDATA[
WITH v151_base AS (
WITH election_cycle_periods AS (
    SELECT 
        (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) || '-' || (1994 + (FLOOR((year_series - 1994) / 4.0) * 4) + 4) AS election_cycle_id,
        (year_series - (1994 + (FLOOR((year_series - 1994) / 4.0) * 4)) + 1) AS cycle_year,
        year_series AS calendar_year
    FROM generate_series(1994, EXTRACT(YEAR FROM CURRENT_DATE)::INTEGER + 4, 1) AS year_series
)
SELECT 
    ecp.election_cycle_id,
    ecp.cycle_year,
    ecp.calendar_year,
    CASE WHEN pdf.decision_month_num >= 9 OR pdf.decision_month_num <= 1 THEN 'autumn' ELSE 'spring' END AS semester,
    pdf.party,
    
    -- From view_riksdagen_party_decision_flow (party-level outcomes)
    SUM(pdf.total_proposals) AS total_proposals,
    SUM(pdf.approved_proposals) AS approved_proposals,
    SUM(pdf.rejected_proposals) AS rejected_proposals,
    ROUND(AVG(pdf.approval_rate), 2) AS avg_approval_rate,
    
    -- Decision effectiveness classification
    CASE 
        WHEN AVG(pdf.approval_rate) >= 75 THEN 'HIGHLY_EFFECTIVE'
        WHEN AVG(pdf.approval_rate) >= 50 THEN 'MODERATELY_EFFECTIVE'
        ELSE 'LOWLY_EFFECTIVE'
    END AS decision_effectiveness,
    
    -- From view_decision_temporal_trends (NEW - temporal decision patterns)
    ROUND(AVG(dtt.daily_approval_rate), 2) AS temporal_approval_rate,
    SUM(dtt.daily_decisions) AS temporal_decision_count,
    
    -- From view_ministry_decision_impact (NEW - government decision effectiveness)
    ROUND(AVG(mdi.approval_rate), 2) AS ministry_impact_score,
    COUNT(DISTINCT mdi.ministry_code) AS ministries_with_decisions
    
FROM election_cycle_periods ecp
LEFT JOIN view_riksdagen_party_decision_flow pdf
    ON pdf.decision_year = ecp.calendar_year
LEFT JOIN view_decision_temporal_trends dtt
    ON EXTRACT(YEAR FROM dtt.decision_day) = ecp.calendar_year
LEFT JOIN view_ministry_decision_impact mdi
    ON mdi.decision_year = ecp.calendar_year
WHERE pdf.party IS NOT NULL
GROUP BY ecp.election_cycle_id, ecp.cycle_year, ecp.calendar_year, 
    CASE WHEN pdf.decision_month_num >= 9 OR pdf.decision_month_num <= 1 THEN 'autumn' ELSE 'spring' END, 
    pdf.party
HAVING SUM(pdf.total_proposals) > 0
ORDER BY election_cycle_id, cycle_year, semester, party
),
windowed AS (
    SELECT v.*,
        RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_approval_rate DESC NULLS LAST) AS rank_by_success_rate,
        RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.total_proposals DESC NULLS LAST) AS rank_by_proposals,
        PERCENT_RANK() OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_approval_rate DESC NULLS LAST) AS percent_rank_success,
        NTILE(4) OVER (PARTITION BY v.election_cycle_id ORDER BY v.avg_approval_rate DESC NULLS LAST) AS ntile_effectiveness,
        LAG(v.avg_approval_rate) OVER (PARTITION BY v.election_cycle_id, v.party ORDER BY v.cycle_year, v.semester) AS prev_semester_success,
        LAG(v.total_proposals) OVER (PARTITION BY v.election_cycle_id, v.party ORDER BY v.cycle_year, v.semester) AS prev_semester_proposals,
        MAX(v.total_proposals) OVER (PARTITION BY v.election_cycle_id) AS max_cycle_proposals
    FROM v151_base v
)
SELECT w.*,
    CASE WHEN w.prev_semester_success IS NOT NULL AND w.prev_semester_success > 0 
         THEN ROUND(((w.avg_approval_rate - w.prev_semester_success) / w.prev_semester_success * 100)::NUMERIC, 2)
         ELSE NULL END AS change_success_pct,
    CASE WHEN w.prev_semester_proposals IS NOT NULL AND w.prev_semester_proposals > 0 
         THEN ROUND(((w.total_proposals - w.prev_semester_proposals)::NUMERIC / w.prev_semester_proposals * 100)::NUMERIC, 2)
         ELSE NULL END AS change_proposals_pct,
    CASE WHEN w.prev_semester_success IS NULL THEN 'baseline'
         WHEN w.avg_approval_rate > w.prev_semester_success + 10 THEN 'improving'
         WHEN w.avg_approval_rate < w.prev_semester_success - 10 THEN 'declining'
         ELSE 'stable' END AS decision_trend,
    ROUND((w.avg_approval_rate * 0.6 + (w.total_proposals::NUMERIC / NULLIF(w.max_cycle_proposals, 0)) * 40)::NUMERIC, 2) AS legislative_momentum
FROM windowed w;
        ]]>
    </createView>
</changeSet>

</databaseChangeLog>
