name: "Copilot Setup Steps"

# Automatically run the setup steps when they are changed to allow for easy validation, and
# allow manual testing through the repository's "Actions" tab
on:
  workflow_dispatch:
  push:
    paths:
      - .github/workflows/copilot-setup-steps.yml
  pull_request:
    paths:
      - .github/workflows/copilot-setup-steps.yml

env:
  GITHUB_TOKEN: ${{ secrets.COPILOT_MCP_GITHUB_PERSONAL_ACCESS_TOKEN }}
  GITHUB_PERSONAL_ACCESS_TOKEN: ${{ secrets.COPILOT_MCP_GITHUB_PERSONAL_ACCESS_TOKEN }}

jobs:
  # The job MUST be called `copilot-setup-steps` or it will not be picked up by Copilot.
  copilot-setup-steps:
    runs-on: ubuntu-latest

    # Set the permissions to the lowest permissions possible needed for your steps.
    # Copilot will be given its own token for its operations.
    permissions:
      contents: read
      actions: read
      attestations: read
      checks: read
      deployments: read
      issues: write
      models: read
      discussions: read
      pages: read
      pull-requests: write
      security-events: read
      statuses: read

    # Steps run before the agent starts working
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Set up JDK 25
        uses: actions/setup-java@be666c2fcd27ec809703dec50e508c2fdc7f6654 # v5.2.0
        with:
          distribution: "temurin"
          java-version: "25"
          cache: "maven"

      - name: Cache Maven and Sonar artifacts
        uses: actions/cache@cdf6c1fa76f9f475f3d7449005a359c84ca0f306 # v5.0.3
        with:
          path: |
            ~/.m2/repository
            ~/.sonar/cache
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-
      - name: Cache APT packages
        uses: actions/cache@cdf6c1fa76f9f475f3d7449005a359c84ca0f306 # v5.0.3
        with:
          path: /var/cache/apt/archives
          key: ${{ runner.os }}-apt-${{ hashFiles('.github/workflows/copilot-setup-steps.yml') }}
          restore-keys: |
            ${{ runner.os }}-apt-

      - name: APT update
        run: sudo apt-get update

      - name: Install buildtools and PostgreSQL
        run: sudo apt-get install -y graphviz build-essential fakeroot devscripts debhelper dh-make wget ant postgresql-16 postgresql-contrib-16 postgresql-16-pgaudit postgresql-16-pgvector

      - name: Configure PostgreSQL
        run: |
          # Enable prepared transactions and required extensions
          sudo sed -i "s/#max_prepared_transactions = 0/max_prepared_transactions = 100/" /etc/postgresql/16/main/postgresql.conf
          sudo sed -i "s/#shared_preload_libraries = ''/shared_preload_libraries = 'pg_stat_statements, pgaudit, pgcrypto, auto_explain'/" /etc/postgresql/16/main/postgresql.conf
          echo "pgaudit.log = ddl" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "pg_stat_statements.track = all" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "pg_stat_statements.max = 10000" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Performance optimization settings per README-SCHEMA-MAINTENANCE.md
          # Memory settings (adjusted for GitHub Actions ~7GB RAM, lower than production recommendations)
          echo "shared_buffers = '1GB'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "effective_cache_size = '4GB'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "work_mem = '32MB'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "maintenance_work_mem = '256MB'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Checkpoint settings for write performance
          echo "checkpoint_completion_target = 0.9" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "wal_buffers = '16MB'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "max_wal_size = '2GB'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "min_wal_size = '512MB'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Query planning optimizations (SSD storage on GitHub Actions)
          echo "random_page_cost = 1.1" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "effective_io_concurrency = 200" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Connection settings (reduced for CI environment)
          echo "max_connections = 100" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Extended Statistics for Better Query Planning
          # Note: default_statistics_target = 100 is PostgreSQL's default, but explicitly set for documentation clarity
          echo "default_statistics_target = 100" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "constraint_exclusion = partition" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Auto-Explain Extension for Automatic Query Plan Logging
          echo "auto_explain.log_min_duration = 1000" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "auto_explain.log_analyze = true" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "auto_explain.log_buffers = true" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "auto_explain.log_timing = true" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "auto_explain.log_verbose = true" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Enhanced pg_stat_statements Configuration
          echo "pg_stat_statements.track_planning = on" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "pg_stat_statements.track_utility = on" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Query Planner Settings for View Analysis
          echo "enable_partitionwise_join = on" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "enable_partitionwise_aggregate = on" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "jit = on" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "jit_above_cost = 100000" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Statistics Collection Enhancement
          echo "track_activities = on" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "track_counts = on" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "track_io_timing = on" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "track_functions = all" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Logging for Query Analysis
          echo "log_min_duration_statement = 1000" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "log_statement = 'ddl'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Add IPv6 loopback access
          echo "host all all ::1/128 md5" | sudo tee -a /etc/postgresql/16/main/pg_hba.conf

      - name: Generate SSL certificates for PostgreSQL
        run: |
          # Generate secure random passphrase
          openssl rand -base64 48 > passphrase.txt

          # Create passphrase-protected private key (increased to 4096 bits)
          openssl genrsa -des3 -passout file:passphrase.txt -out server.pass.key 4096

          # Remove passphrase protection from private key
          openssl rsa -passin file:passphrase.txt -in server.pass.key -out server.key
          rm server.pass.key

          # Create OpenSSL config file with Subject Alternative Names
          cat > openssl.cnf <<EOL
          [req]
          default_bits = 4096
          prompt = no
          default_md = sha256
          req_extensions = req_ext
          distinguished_name = dn

          [dn]
          C=UK
          ST=PostgreSQL
          L=Docker
          O=Hack23
          OU=demo
          CN=localhost

          [req_ext]
          subjectAltName = @alt_names

          [alt_names]
          DNS.1 = localhost
          IP.1 = 127.0.0.1
          EOL

          # Create Certificate Signing Request with config
          openssl req -new -key server.key -out server.csr -config openssl.cnf

          # Self-sign the certificate with extensions (valid for 10 years)
          openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt -extensions req_ext -extfile openssl.cnf

          # Clean up temporary files
          rm passphrase.txt server.csr openssl.cnf

      - name: Deploy SSL certificate and key for PostgreSQL
        run: |
          # Secure the certificate files
          chmod 600 server.key server.crt

          # Copy certificate and key to PostgreSQL data directory
          sudo cp server.crt /var/lib/postgresql/16/main/server.crt
          sudo cp server.key /var/lib/postgresql/16/main/server.key

          # Secure the certificate and key
          sudo chmod 600 /var/lib/postgresql/16/main/server.key
          sudo chmod 644 /var/lib/postgresql/16/main/server.crt
          sudo chown postgres:postgres /var/lib/postgresql/16/main/server.key
          sudo chown postgres:postgres /var/lib/postgresql/16/main/server.crt

          # Enable SSL in PostgreSQL
          echo "ssl = on" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "ssl_cert_file = '/var/lib/postgresql/16/main/server.crt'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf
          echo "ssl_key_file = '/var/lib/postgresql/16/main/server.key'" | sudo tee -a /etc/postgresql/16/main/postgresql.conf

          # Provide SSL certificate to the runner user
          mkdir -p $HOME/.postgresql
          cp server.crt $HOME/.postgresql/root.crt
          chmod 600 $HOME/.postgresql/root.crt

          # Clean up
          rm server.key server.crt

          # Restart PostgreSQL to apply all changes
          sudo systemctl restart postgresql

      - name: Create CIA database and user
        run: |
          sudo -u postgres psql -c "CREATE USER eris WITH PASSWORD 'discord';"
          sudo -u postgres psql -c "CREATE DATABASE cia_dev;"
          sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE cia_dev TO eris;"
          sudo -u postgres psql -c "ALTER USER eris WITH SUPERUSER;"
          sudo -u postgres psql -d cia_dev -c "CREATE EXTENSION IF NOT EXISTS pg_stat_statements;"
          sudo -u postgres psql -d cia_dev -c "CREATE EXTENSION IF NOT EXISTS pgaudit;"
          sudo -u postgres psql -d cia_dev -c "CREATE EXTENSION IF NOT EXISTS pgcrypto;"
          sudo -u postgres psql -d cia_dev -c "GRANT ALL ON SCHEMA public TO eris;"
          sudo -u postgres psql -d cia_dev -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO eris;"
          sudo -u postgres psql -d cia_dev -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO eris;"
          sudo -u postgres psql -d cia_dev -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON FUNCTIONS TO eris;"

      - name: Load database schema
        run: |
          # Load the full schema into the database
          sudo -u postgres psql -d cia_dev -f service.data.impl/src/main/resources/full_schema.sql || echo "Schema load completed with warnings (expected for first-time setup)"

          # Verify schema loaded successfully by checking for key tables
          echo "Verifying schema loaded..."
          sudo -u postgres psql -d cia_dev -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" || echo "Schema verification completed"

      - name: Generate statistics for view analysis
        run: |
          # Run ANALYZE on all tables to generate statistics
          echo "Generating table statistics for accurate EXPLAIN analysis..."
          sudo -u postgres psql -d cia_dev -c "ANALYZE;"
          
          # Verify statistics were generated
          echo "Verifying statistics collection..."
          sudo -u postgres psql -d cia_dev -c "SELECT schemaname, relname, last_analyze, last_autoanalyze FROM pg_stat_user_tables ORDER BY relname LIMIT 20;"
          
          # Show current statistics targets
          echo "Sample statistics for verification..."
          sudo -u postgres psql -d cia_dev -c "SELECT tablename, attname, n_distinct, correlation FROM pg_stats WHERE schemaname = 'public' ORDER BY tablename LIMIT 20;"

      - name: Verify PostgreSQL SSL configuration
        run: |
          # Verify SSL is enabled
          sudo -u postgres psql -c "SHOW ssl;" | grep on

          # Verify prepared transactions are enabled
          sudo -u postgres psql -c "SHOW max_prepared_transactions;" | grep 100

          # Verify extensions are loaded
          sudo -u postgres psql -d cia_dev -c "\dx" | grep pg_stat_statements
          sudo -u postgres psql -d cia_dev -c "\dx" | grep pgaudit
          sudo -u postgres psql -d cia_dev -c "\dx" | grep pgcrypto

          # Test SSL connection from localhost
          echo "Testing SSL connection..."
          PGPASSWORD=discord PGSSLMODE=require psql -h localhost -U eris -d cia_dev -c "SELECT version();" || echo "SSL connection test completed"

      - name: Set up Maven
        uses: stCarolas/setup-maven@d6af6abeda15e98926a57b5aa970a96bb37f97d1 # v5
        with:
          maven-version: 3.9.9

      - name: Build with Maven
        run: mvn -B clean install --file pom.xml -Prelease-site,all-modules -DskipTests -DfailIfNoTests=false -Dsurefire.failIfNoSpecifiedTests=false -Dspdx.skip=true

      - name: Validate app startup and database connection
        run: |
          cd citizen-intelligence-agency

          # Start the application in background with a timeout
          echo "Starting application..."
          timeout 240 ant start > /tmp/app-startup.log 2>&1 &
          APP_PID=$!

          echo "Application starting with PID: $APP_PID"

          # Wait for application to start and apply database changelogs
          MAX_WAIT=60
          for i in $(seq 1 $MAX_WAIT); do
            if sudo -u postgres psql -d cia_dev -c "SELECT COUNT(*) FROM databasechangelog;" > /dev/null 2>&1; then
              echo "✓ Database changelogs verified successfully"
              CHANGELOG_COUNT=$(sudo -u postgres psql -d cia_dev -t -c "SELECT COUNT(*) FROM databasechangelog;")
              echo "  Found $CHANGELOG_COUNT changelog entries"
              break
            fi
            echo "Waiting for application to initialize and apply changelogs... ($i/$MAX_WAIT)"
            sleep 3
          done

          # Check if we successfully verified the changelogs
          if sudo -u postgres psql -d cia_dev -c "SELECT COUNT(*) FROM databasechangelog;" > /dev/null 2>&1; then
            echo "✓ Application startup validation successful"
          else
            echo "⚠ Database changelog table not created yet - check logs"
            echo "Application logs:"
            tail -50 /tmp/app-startup.log || echo "No logs available"
          fi

          PORT=28443
          APP_URL="https://localhost:${PORT}/cia/"
          MAX_PORT_WAIT=60
          PORT_READY=0

          # Wait for port to be listening
          echo "Waiting for port ${PORT} to open..."
          for i in $(seq 1 30); do
            if ss -ltn | grep -q ":${PORT} "; then
              echo "✓ Port ${PORT} is listening (${i}/30)"
              break
            fi
            echo "  Waiting for port ${PORT} to open (${i}/30)"
            sleep 2
          done

          # Now wait for actual HTTP readiness by monitoring logs
          echo "Waiting for application to be ready for requests..."
          for i in $(seq 1 $MAX_PORT_WAIT); do
            # Check if server reports it's started
            if grep -q "Server Started" /tmp/app-startup.log 2>/dev/null; then
              echo "✓ Application reports server started"
              # Give it a moment to finish initialization
              sleep 3
              
              # Try HTTP request
              if curl --insecure --silent --show-error --fail --max-time 5 "$APP_URL" >/dev/null 2>&1; then
                echo "✓ Application responded over HTTPS at ${APP_URL}"
                PORT_READY=1
                break
              else
                echo "  Server started but HTTP not ready yet, retrying..."
              fi
            fi
            
            # Fallback: check for Spring context initialization complete
            if grep -q "Root WebApplicationContext: initialization completed" /tmp/app-startup.log 2>/dev/null; then
              echo "✓ Spring context initialization completed"
              sleep 2
              
              if curl --insecure --silent --show-error --fail --max-time 5 "$APP_URL" >/dev/null 2>&1; then
                echo "✓ Application responded over HTTPS at ${APP_URL}"
                PORT_READY=1
                break
              fi
            fi
            
            sleep 2
          done

          if [ "$PORT_READY" -ne 1 ]; then
            echo "⚠ Application never responded on ${APP_URL}"
            echo "Server status:"
            ss -ltnp | grep "${PORT}" || true
            echo ""
            echo "Last 100 lines of application log:"
            tail -100 /tmp/app-startup.log || true
          else
            echo "✓ Application validation successful - server is ready"
          fi

          # Stop the application gracefully
          if kill -0 $APP_PID 2>/dev/null; then
            echo "Stopping application (PID: $APP_PID)..."
            kill $APP_PID 2>/dev/null || true
            sleep 2
            kill -9 $APP_PID 2>/dev/null || true
          fi

          wait $APP_PID 2>/dev/null || echo "Application validation completed"
